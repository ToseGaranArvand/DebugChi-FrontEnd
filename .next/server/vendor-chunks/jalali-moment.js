/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jalali-moment";
exports.ids = ["vendor-chunks/jalali-moment"];
exports.modules = {

/***/ "(ssr)/./node_modules/jalali-moment/jalali-moment.js":
/*!*****************************************************!*\
  !*** ./node_modules/jalali-moment/jalali-moment.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = jMoment;\n\nvar moment = __webpack_require__(/*! moment/moment */ \"(ssr)/./node_modules/moment/moment.js\");\n__webpack_require__(/*! moment/locale/fa */ \"(ssr)/./node_modules/moment/locale/fa.js\");\n\n/************************************\n Constants\n ************************************/\n\nvar formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?j(Mo|MM?M?M?|Do|DDDo|DD?D?D?|w[o|w]?|YYYYY|YYYY|YY|gg(ggg?)?|)|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g\n    , localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LT|LL?L?L?|l{1,4})/g\n    , parseTokenOneOrTwoDigits = /\\d\\d?/\n    , parseTokenOneToThreeDigits = /\\d{1,3}/\n    , parseTokenThreeDigits = /\\d{3}/\n    , parseTokenFourDigits = /\\d{1,4}/\n    , parseTokenSixDigits = /[+\\-]?\\d{1,6}/\n    , parseTokenWord = /[0-9]*[\"a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i\n    , parseTokenTimezone = /Z|[\\+\\-]\\d\\d:?\\d\\d/i\n    , parseTokenT = /T/i\n    , parseTokenTimestampMs = /[\\+\\-]?\\d+(\\.\\d{1,3})?/\n\n    , unitAliases = {\n        jm: \"jmonth\"\n        , jmonths: \"jmonth\"\n        , jy: \"jyear\"\n        , jyears: \"jyear\"\n    }\n\n    , formatFunctions = {}\n\n    , ordinalizeTokens = \"DDD w M D\".split(\" \")\n    , paddedTokens = \"M D w\".split(\" \");\n\nvar CalendarSystems = {\n    Jalali: 1,\n    Gregorian: 2,\n}\nvar formatTokenFunctions = {\n    jM: function () {\n        return this.jMonth() + 1;\n    },\n    jMMM: function (format) {\n        return this.localeData().jMonthsShort(this, format);\n    },\n    jMMMM: function (format) {\n        return this.localeData().jMonths(this, format);\n    },\n    jD: function () {\n        return this.jDate();\n    },\n    jDDD: function () {\n        return this.jDayOfYear();\n    },\n    jw: function () {\n        return this.jWeek();\n    },\n    jYY: function () {\n        return leftZeroFill(this.jYear() % 100, 2);\n    },\n    jYYYY: function () {\n        return leftZeroFill(this.jYear(), 4);\n    },\n    jYYYYY: function () {\n        return leftZeroFill(this.jYear(), 5);\n    },\n    jgg: function () {\n        return leftZeroFill(this.jWeekYear() % 100, 2);\n    },\n    jgggg: function () {\n        return this.jWeekYear();\n    },\n    jggggg: function () {\n        return leftZeroFill(this.jWeekYear(), 5);\n    }\n};\n\nfunction padToken(func, count) {\n    return function (a) {\n        return leftZeroFill(func.call(this, a), count);\n    };\n}\nfunction ordinalizeToken(func, period) {\n    return function (a) {\n        return this.localeData().ordinal(func.call(this, a), period);\n    };\n}\n\n(function () {\n    var i;\n    while (ordinalizeTokens.length) {\n        i = ordinalizeTokens.pop();\n        formatTokenFunctions[\"j\" + i + \"o\"] = ordinalizeToken(formatTokenFunctions[\"j\" + i], i);\n    }\n    while (paddedTokens.length) {\n        i = paddedTokens.pop();\n        formatTokenFunctions[\"j\" + i + i] = padToken(formatTokenFunctions[\"j\" + i], 2);\n    }\n    formatTokenFunctions.jDDDD = padToken(formatTokenFunctions.jDDD, 3);\n}());\n\n/************************************\n Helpers\n ************************************/\n\nfunction extend(a, b) {\n    var key;\n    for (key in b)\n        if (b.hasOwnProperty(key)){\n            a[key] = b[key];\n        }\n    return a;\n}\n\n/**\n * return a string which length is as much as you need\n * @param {number} number input\n * @param {number} targetLength expected length\n * @example leftZeroFill(5,2) => 05\n **/\nfunction leftZeroFill(number, targetLength) {\n    var output = number + \"\";\n    while (output.length < targetLength){\n        output = \"0\" + output;\n    }\n    return output;\n}\n\n/**\n * determine object is array or not\n * @param input\n **/\nfunction isArray(input) {\n    return Object.prototype.toString.call(input) === \"[object Array]\";\n}\n\n/**\n * Changes any moment Gregorian format to Jalali system format\n * @param {string} format\n * @example toJalaliFormat(\"YYYY/MMM/DD\") => \"jYYYY/jMMM/jDD\"\n **/\nfunction toJalaliFormat(format) {\n    for (var i = 0; i < format.length; i++) {\n        if(!i || (format[i-1] !== \"j\" && format[i-1] !== format[i])) {\n            if (format[i] === \"Y\" || format[i] === \"M\" || format[i] === \"D\" || format[i] === \"g\") {\n                format = format.slice(0, i) + \"j\" + format.slice(i);\n            }\n        }\n    }\n    return format;\n}\n\n/**\n * Changes any moment Gregorian units to Jalali system units\n * @param {string} units\n * @example toJalaliUnit(\"YYYY/MMM/DD\") => \"jYYYY/jMMM/jDD\"\n **/\nfunction toJalaliUnit(units) {\n    switch (units) {\n        case \"week\" : return \"jWeek\";\n        case \"year\" : return \"jYear\";\n        case \"month\" : return \"jMonth\";\n        case \"months\" : return \"jMonths\";\n        case \"monthName\" : return \"jMonthsShort\";\n        case \"monthsShort\" : return \"jMonthsShort\";\n    }\n    return units;\n}\n\n/**\n * normalize units to be comparable\n * @param {string} units\n **/\nfunction normalizeUnits(units, momentObj) {\n    if (isJalali(momentObj)) {\n        units = toJalaliUnit(units);\n    }\n     if (units) {\n        var lowered = units.toLowerCase();\n        if (lowered.startsWith('j')) units = unitAliases[lowered] || lowered;\n        // TODO : add unit test\n        if (units === \"jday\") units = \"day\";\n        else if (units === \"jd\") units = \"d\";\n    }\n    return units;\n}\n\n/**\n * set a gregorian date to moment object\n * @param {string} momentInstance\n * @param {string} year in gregorian system\n * @param {string} month in gregorian system\n * @param {string} day in gregorian system\n **/\nfunction setDate(momentInstance, year, month, day) {\n    var d = momentInstance._d;\n    if (momentInstance._isUTC) {\n        /*eslint-disable new-cap*/\n        momentInstance._d = new Date(Date.UTC(year, month, day,\n            d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()));\n        /*eslint-enable new-cap*/\n    } else {\n        momentInstance._d = new Date(year, month, day,\n            d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n    }\n}\n\nfunction objectCreate(parent) {\n    function F() {}\n    F.prototype = parent;\n    return new F();\n}\n\nfunction getPrototypeOf(object) {\n    if (Object.getPrototypeOf){\n        return Object.getPrototypeOf(object);\n    }\n    else if (\"\".__proto__){\n        return object.__proto__;\n    }\n    else{\n        return object.constructor.prototype;\n    }\n}\n\n/************************************\n Languages\n ************************************/\nextend(getPrototypeOf(moment.localeData()),\n    { _jMonths: [ \"Farvardin\"\n        , \"Ordibehesht\"\n        , \"Khordaad\"\n        , \"Tir\"\n        , \"Mordaad\"\n        , \"Shahrivar\"\n        , \"Mehr\"\n        , \"Aabaan\"\n        , \"Aazar\"\n        , \"Dey\"\n        , \"Bahman\"\n        , \"Esfand\"\n    ]\n        , jMonths: function (m) {\n            if (m) {\n                return this._jMonths[m.jMonth()];\n            } else {\n                return this._jMonths;\n            }\n    }\n\n        , _jMonthsShort:  [ \"Far\"\n        , \"Ord\"\n        , \"Kho\"\n        , \"Tir\"\n        , \"Amo\"\n        , \"Sha\"\n        , \"Meh\"\n        , \"Aab\"\n        , \"Aaz\"\n        , \"Dey\"\n        , \"Bah\"\n        , \"Esf\"\n    ]\n        , jMonthsShort: function (m) {\n        if (m) {\n            return this._jMonthsShort[m.jMonth()];\n        } else {\n            return this._jMonthsShort;\n        }\n    }\n\n        , jMonthsParse: function (monthName) {\n        var i\n            , mom\n            , regex;\n        if (!this._jMonthsParse){\n            this._jMonthsParse = [];\n        }\n        for (i = 0; i < 12; i += 1) {\n            // Make the regex if we don\"t have it already.\n            if (!this._jMonthsParse[i]) {\n                mom = jMoment([2000, (2 + i) % 12, 25]);\n                regex = \"^\" + this.jMonths(mom, \"\") + \"|^\" + this.jMonthsShort(mom, \"\");\n                this._jMonthsParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n            }\n            // Test the regex.\n            if (this._jMonthsParse[i].test(monthName)){\n                return i;\n            }\n        }\n    }\n    }\n);\n\n/************************************\n Formatting\n ************************************/\n\nfunction makeFormatFunction(format) {\n    var array = format.match(formattingTokens)\n        , length = array.length\n        , i;\n\n    for (i = 0; i < length; i += 1){\n        if (formatTokenFunctions[array[i]]){\n            array[i] = formatTokenFunctions[array[i]];\n        }\n    }\n    return function (mom) {\n        var output = \"\";\n        for (i = 0; i < length; i += 1){\n            output += array[i] instanceof Function ? \"[\" + array[i].call(mom, format) + \"]\" : array[i];\n        }\n        return output;\n    };\n}\n\n/************************************\n Parsing\n ************************************/\n\nfunction getParseRegexForToken(token, config) {\n    switch (token) {\n        case \"jDDDD\":\n            return parseTokenThreeDigits;\n        case \"jYYYY\":\n            return parseTokenFourDigits;\n        case \"jYYYYY\":\n            return parseTokenSixDigits;\n        case \"jDDD\":\n            return parseTokenOneToThreeDigits;\n        case \"jMMM\":\n        case \"jMMMM\":\n            return parseTokenWord;\n        case \"jMM\":\n        case \"jDD\":\n        case \"jYY\":\n        case \"jM\":\n        case \"jD\":\n            return parseTokenOneOrTwoDigits;\n        case \"DDDD\":\n            return parseTokenThreeDigits;\n        case \"YYYY\":\n            return parseTokenFourDigits;\n        case \"YYYYY\":\n            return parseTokenSixDigits;\n        case \"S\":\n        case \"SS\":\n        case \"SSS\":\n        case \"DDD\":\n            return parseTokenOneToThreeDigits;\n        case \"MMM\":\n        case \"MMMM\":\n        case \"dd\":\n        case \"ddd\":\n        case \"dddd\":\n            return parseTokenWord;\n        case \"a\":\n        case \"A\":\n            return moment.localeData(config._l)._meridiemParse;\n        case \"X\":\n            return parseTokenTimestampMs;\n        case \"Z\":\n        case \"ZZ\":\n            return parseTokenTimezone;\n        case \"T\":\n            return parseTokenT;\n        case \"MM\":\n        case \"DD\":\n        case \"YY\":\n        case \"HH\":\n        case \"hh\":\n        case \"mm\":\n        case \"ss\":\n        case \"M\":\n        case \"D\":\n        case \"d\":\n        case \"H\":\n        case \"h\":\n        case \"m\":\n        case \"s\":\n            return parseTokenOneOrTwoDigits;\n        default:\n            return new RegExp(token.replace(\"\\\\\", \"\"));\n    }\n}\nfunction isNull(variable) {\n    return variable === null || variable === undefined;\n}\nfunction addTimeToArrayFromToken(token, input, config) {\n    var a\n        , datePartArray = config._a;\n\n    switch (token) {\n        case \"jM\":\n        case \"jMM\":\n            datePartArray[1] = isNull(input)? 0 : ~~input - 1;\n            break;\n        case \"jMMM\":\n        case \"jMMMM\":\n            a = moment.localeData(config._l).jMonthsParse(input);\n            if (!isNull(a)){\n                datePartArray[1] = a;\n            }\n            else{\n                config._isValid = false;\n            }\n            break;\n        case \"jD\":\n        case \"jDD\":\n        case \"jDDD\":\n        case \"jDDDD\":\n            if (!isNull(input)){\n                datePartArray[2] = ~~input;\n            }\n            break;\n        case \"jYY\":\n            datePartArray[0] = ~~input + (~~input > 47 ? 1300 : 1400);\n            break;\n        case \"jYYYY\":\n        case \"jYYYYY\":\n            datePartArray[0] = ~~input;\n    }\n    if (isNull(input)) {\n        config._isValid = false;\n    }\n}\n\nfunction dateFromArray(config) {\n    var g\n        , j\n        , jy = config._a[0]\n        , jm = config._a[1]\n        , jd = config._a[2];\n\n    if (isNull(jy) && isNull(jm) && isNull(jd)){\n        return;\n    }\n    jy = !isNull(jy) ? jy : 0;\n    jm = !isNull(jm) ? jm : 0;\n    jd = !isNull(jd) ? jd : 1;\n    if (jd < 1 || jd > jMoment.jDaysInMonth(jy, jm) || jm < 0 || jm > 11){\n        config._isValid = false;\n    }\n    g = toGregorian(jy, jm, jd);\n    j = toJalali(g.gy, g.gm, g.gd);\n    config._jDiff = 0;\n    if (~~j.jy !== jy){\n        config._jDiff += 1;\n    }\n    if (~~j.jm !== jm){\n        config._jDiff += 1;\n    }\n    if (~~j.jd !== jd){\n        config._jDiff += 1;\n    }\n    return [g.gy, g.gm, g.gd];\n}\n\nfunction makeDateFromStringAndFormat(config) {\n    var tokens = config._f.match(formattingTokens)\n        , string = config._i + \"\"\n        , len = tokens.length\n        , i\n        , token\n        , parsedInput;\n\n    config._a = [];\n\n    for (i = 0; i < len; i += 1) {\n        token = tokens[i];\n        parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];\n        if (parsedInput){\n            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n        }\n        if (formatTokenFunctions[token]){\n            addTimeToArrayFromToken(token, parsedInput, config);\n        }\n    }\n    if (string){\n        config._il = string;\n    }\n    return dateFromArray(config);\n}\n\nfunction makeDateFromStringAndArray(config, utc) {\n    var len = config._f.length\n        , i\n        , format\n        , tempMoment\n        , bestMoment\n        , currentScore\n        , scoreToBeat;\n\n    if (len === 0) {\n        return makeMoment(new Date(NaN));\n    }\n\n    for (i = 0; i < len; i += 1) {\n        format = config._f[i];\n        currentScore = 0;\n        tempMoment = makeMoment(config._i, format, config._l, config._strict, utc);\n\n        if (!tempMoment.isValid()){\n            continue;\n        }\n\n        // currentScore = compareArrays(tempMoment._a, tempMoment.toArray())\n        currentScore += tempMoment._jDiff;\n        if (tempMoment._il){\n            currentScore += tempMoment._il.length;\n        }\n        if (isNull(scoreToBeat) || currentScore < scoreToBeat) {\n            scoreToBeat = currentScore;\n            bestMoment = tempMoment;\n        }\n    }\n\n    return bestMoment;\n}\n\nfunction removeParsedTokens(config) {\n    var string = config._i + \"\"\n        , input = \"\"\n        , format = \"\"\n        , array = config._f.match(formattingTokens)\n        , len = array.length\n        , i\n        , match\n        , parsed;\n\n    for (i = 0; i < len; i += 1) {\n        match = array[i];\n        parsed = (getParseRegexForToken(match, config).exec(string) || [])[0];\n        if (parsed){\n            string = string.slice(string.indexOf(parsed) + parsed.length);\n        }\n        if (!(formatTokenFunctions[match] instanceof Function)) {\n            format += match;\n            if (parsed){\n                input += parsed;\n            }\n        }\n    }\n    config._i = input;\n    config._f = format;\n}\n\n/************************************\n Week of Year\n ************************************/\n\nfunction jWeekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n    var end = firstDayOfWeekOfYear - firstDayOfWeek\n        , daysToDayOfWeek = firstDayOfWeekOfYear - mom.day()\n        , adjustedMoment;\n\n    if (daysToDayOfWeek > end) {\n        daysToDayOfWeek -= 7;\n    }\n    if (daysToDayOfWeek < end - 7) {\n        daysToDayOfWeek += 7;\n    }\n    adjustedMoment = jMoment(mom).add(daysToDayOfWeek, \"d\");\n    return  { week: Math.ceil(adjustedMoment.jDayOfYear() / 7)\n        , year: adjustedMoment.jYear()\n    };\n}\n\n/************************************\n Top Level Functions\n ************************************/\nfunction isJalali (momentObj) {\n    return momentObj &&\n        (momentObj.calSystem === CalendarSystems.Jalali) ||\n        (moment.justUseJalali && momentObj.calSystem !== CalendarSystems.Gregorian);\n}\nfunction isInputJalali(format, momentObj, input) {\n    return (moment.justUseJalali || (momentObj && momentObj.calSystem === CalendarSystems.Jalali))\n}\nfunction makeMoment(input, format, lang, strict, utc) {\n    if (typeof lang === \"boolean\") {\n        utc = utc || strict;\n        strict = lang;\n        lang = undefined;\n    }\n    if (moment.ISO_8601 === format) {\n        format = 'YYYY-MM-DDTHH:mm:ss.SSSZ';\n    }\n    const inputIsJalali = isInputJalali(format, this, input);\n    // var itsJalaliDate = (isJalali(this));\n    if(input && (typeof input === \"string\") && !format && inputIsJalali && !moment.useGregorianParser) {\n        input = input.replace(/\\//g,\"-\");\n        if(/\\d{4}\\-\\d{2}\\-\\d{2}/.test(input)) {\n            format = \"jYYYY-jMM-jDD\";\n        } else if (/\\d{4}\\-\\d{2}\\-\\d{1}/.test(input)) {\n            format = \"jYYYY-jMM-jD\";\n        } else if (/\\d{4}\\-\\d{1}\\-\\d{1}/.test(input)) {\n            format = \"jYYYY-jM-jD\";\n        } else if (/\\d{4}\\-\\d{1}\\-\\d{2}/.test(input)) {\n            format = \"jYYYY-jM-jDD\";\n        } else if (/\\d{4}\\-W\\d{2}\\-\\d{2}/.test(input)) {\n            format = \"jYYYY-jW-jDD\";\n        } else if (/\\d{4}\\-\\d{3}/.test(input)) {\n            format = \"jYYYY-jDDD\";\n        } else if (/\\d{8}/.test(input)) {\n            format = \"jYYYYjMMjDD\";\n        } else if (/\\d{4}W\\d{2}\\d{1}/.test(input)) {\n            format = \"jYYYYjWWjD\";\n        } else if (/\\d{4}W\\d{2}/.test(input)) {\n            format = \"jYYYYjWW\";\n        } else if (/\\d{4}\\d{3}/.test(input)) {\n            format = \"jYYYYjDDD\";\n        }\n    }\n    if (format && inputIsJalali){\n        format = toJalaliFormat(format);\n    }\n    if (format && typeof format === \"string\"){\n        format = fixFormat(format, moment);\n    }\n\n    var config =\n        { _i: input\n            , _f: format\n            , _l: lang\n            , _strict: strict\n            , _isUTC: utc\n        }\n        , date\n        , m\n        , jm\n        , origInput = input\n        , origFormat = format;\n    if (format) {\n        if (isArray(format)) {\n            return makeDateFromStringAndArray(config, utc);\n        } else {\n            date = makeDateFromStringAndFormat(config);\n            removeParsedTokens(config);\n            if (date) {\n                format = \"YYYY-MM-DD-\" + config._f;\n                input = leftZeroFill(date[0], 4) + \"-\"\n                    + leftZeroFill(date[1] + 1, 2) + \"-\"\n                    + leftZeroFill(date[2], 2) + \"-\"\n                    + config._i;\n            }\n        }\n    }\n    if (utc){\n        m = moment.utc(input, format, lang, strict);\n    }\n    else{\n        m = moment(input, format, lang, strict);\n    }\n    if (config._isValid === false || (input && input._isAMomentObject && !input._isValid)){\n        m._isValid = false;\n    }\n    m._jDiff = config._jDiff || 0;\n    jm = objectCreate(jMoment.fn);\n    extend(jm, m);\n    if (strict && jm.isValid()) {\n        jm._isValid = jm.format(origFormat) === origInput;\n    }\n    if (input && input.calSystem) {\n        jm.calSystem = input.calSystem;\n    }\n    return jm;\n}\n\nfunction jMoment(input, format, lang, strict) {\n    return makeMoment(input, format, lang, strict, false);\n}\n\nextend(jMoment, moment);\njMoment.fn = objectCreate(moment.fn);\n\njMoment.utc = function (input, format, lang, strict) {\n    return makeMoment(input, format, lang, strict, true);\n};\n\njMoment.unix = function (input) {\n    return makeMoment(input * 1000);\n};\n\n/************************************\n jMoment Prototype\n ************************************/\n\nfunction fixFormat(format, _moment) {\n    var i = 5;\n    var replace = function (input) {\n        return _moment.localeData().longDateFormat(input) || input;\n    };\n    while (i > 0 && localFormattingTokens.test(format)) {\n        i -= 1;\n        format = format.replace(localFormattingTokens, replace);\n    }\n    return format;\n}\n\njMoment.fn.format = function (format) {\n\tformat = format || jMoment.defaultFormat;\n    if (format) {\n        if (isJalali(this)) {\n            format = toJalaliFormat(format);\n        }\n        format = fixFormat(format, this);\n\n        if (!formatFunctions[format]) {\n            formatFunctions[format] = makeFormatFunction(format);\n        }\n        format = formatFunctions[format](this);\n    }\n    var formatted = moment.fn.format.call(this, format);\n    return formatted;\n};\n\njMoment.fn.year = function (input) {\n    if (isJalali(this)) return jMoment.fn.jYear.call(this,input);\n    else return moment.fn.year.call(this, input);\n};\njMoment.fn.jYear = function (input) {\n    var lastDay\n        , j\n        , g;\n    if (typeof input === \"number\") {\n        j = getJalaliOf(this);\n        lastDay = Math.min(j.jd, jMoment.jDaysInMonth(input, j.jm));\n        g = toGregorian(input, j.jm, lastDay);\n        setDate(this, g.gy, g.gm, g.gd);\n        moment.updateOffset(this);\n        return this;\n    } else {\n        return getJalaliOf(this).jy;\n    }\n};\n\njMoment.fn.month = function (input) {\n    if (isJalali(this)) return jMoment.fn.jMonth.call(this,input);\n    else return moment.fn.month.call(this, input);\n};\njMoment.fn.jMonth = function (input) {\n    var lastDay\n        , j\n        , g;\n    if (!isNull(input)) {\n        if (typeof input === \"string\") {\n            input = this.localeData().jMonthsParse(input);\n            if (typeof input !== \"number\"){\n                return this;\n            }\n        }\n        j = getJalaliOf(this);\n        lastDay = Math.min(j.jd, jMoment.jDaysInMonth(j.jy, input));\n        this.jYear(j.jy + div(input, 12));\n        input = mod(input, 12);\n        if (input < 0) {\n            input += 12;\n            this.jYear(this.jYear() - 1);\n        }\n        g = toGregorian(this.jYear(), input, lastDay);\n        setDate(this, g.gy, g.gm, g.gd);\n        moment.updateOffset(this);\n        return this;\n    } else {\n        return getJalaliOf(this).jm;\n    }\n};\n\njMoment.fn.date = function (input) {\n    if (isJalali(this)) return jMoment.fn.jDate.call(this,input);\n    else return moment.fn.date.call(this, input);\n};\nfunction getJalaliOf (momentObj) {\n    var d = momentObj._d;\n    if (momentObj._isUTC) {\n        return toJalali(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n    } else {\n        return toJalali(d.getFullYear(), d.getMonth(), d.getDate());\n    }\n}\njMoment.fn.jDate = function (input) {\n    var j\n        , g;\n    if (typeof input === \"number\") {\n        j = getJalaliOf(this);\n        g = toGregorian(j.jy, j.jm, input);\n        setDate(this, g.gy, g.gm, g.gd);\n        moment.updateOffset(this);\n        return this;\n    } else {\n        return getJalaliOf(this).jd;\n    }\n};\n\njMoment.fn.jDay = function (input) {\n    if (typeof input === \"number\") {\n        return moment.fn.day.call(this, input - 1);\n    } else {\n        return (moment.fn.day.call(this) + 1) % 7;\n    }\n};\njMoment.fn.diff = function (input, unitOfTime, asFloat) {\n    //code taken and adjusted for jalali calendar from original moment diff module https://github.com/moment/moment/blob/develop/src/lib/moment/diff.js\n    if (!isJalali(this))\n        return moment.fn.diff.call(this, input, unitOfTime, asFloat);\n\n    var output;\n    switch (unitOfTime) {\n        case \"year\":\n            output = monthDiff(this, input) / 12;\n            break;\n        case \"month\":\n            output = monthDiff(this, input);\n            break;\n        case \"quarter\":\n            output = monthDiff(this, input) / 3;\n            break;\n        default:\n            output = moment.fn.diff.call(this, input, unitOfTime, asFloat);\n    }\n\n    return asFloat ? output : (output < 0 ? Math.ceil(output) || 0 : Math.floor(output));\n\n    function monthDiff(a, b) {\n        if (a.date() < b.date()) {\n            // end-of-month calculations work correct when the start month has more\n            // days than the end month.\n            return -monthDiff(b, a);\n        }\n        // difference in months\n        var wholeMonthDiff = (b.jYear() - a.jYear()) * 12 + (b.jMonth() - a.jMonth()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, \"months\"),\n            anchor2,\n            adjust\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n}\n\njMoment.fn.dayOfYear = function (input) {\n    if (isJalali(this)) return jMoment.fn.jDayOfYear.call(this,input);\n    else return moment.fn.dayOfYear.call(this, input);\n};\njMoment.fn.jDayOfYear = function (input) {\n    var dayOfYear = Math.round((jMoment(this).startOf(\"day\") - jMoment(this).startOf(\"jYear\")) / 864e5) + 1;\n    return isNull(input) ? dayOfYear : this.add(input - dayOfYear, \"d\");\n};\n\njMoment.fn.week = function (input) {\n    if (isJalali(this)) return jMoment.fn.jWeek.call(this,input);\n    else return moment.fn.week.call(this, input);\n};\njMoment.fn.jWeek = function (input) {\n    var week = jWeekOfYear(this, 6, 12).week;\n    return isNull(input) ? week : this.add((input - week) * 7, \"d\");\n};\n\njMoment.fn.weekYear = function (input) {\n    if (isJalali(this)) return jMoment.fn.jWeekYear.call(this,input);\n    else return moment.fn.weekYear.call(this, input);\n};\njMoment.fn.jWeekYear = function (input) {\n    var year = jWeekOfYear(this, 6, 12).year;\n    return isNull(input) ? year : this.add(input - year, \"jyear\");\n};\n\njMoment.fn.add = function (val, units) {\n    var temp;\n    if (!isNull(units) && !isNaN(+units)) {\n        temp = val;\n        val = units;\n        units = temp;\n    }\n    units = normalizeUnits(units, this);\n    if (units === 'jweek' || units==='isoweek') { units = 'week' }\n    if (units === \"jyear\") {\n        this.jYear(this.jYear() + val);\n    } else if (units === \"jmonth\") {\n        this.jMonth(this.jMonth() + val);\n    } else {\n        moment.fn.add.call(this, val, units);\n    }\n    return this;\n};\n\njMoment.fn.subtract = function (val, units) {\n    var temp;\n    if (!isNull(units) && !isNaN(+units)) {\n        temp = val;\n        val = units;\n        units = temp;\n    }\n    units = normalizeUnits(units, this);\n    if (units === \"jyear\") {\n        this.jYear(this.jYear() - val);\n    } else if (units === \"jmonth\") {\n        this.jMonth(this.jMonth() - val);\n    } else {\n        moment.fn.subtract.call(this, val, units);\n    }\n    return this;\n};\n\njMoment.fn.startOf = function (units) {\n    var nunit = normalizeUnits(units, this);\n    if( nunit === \"jweek\"){\n        return this.startOf(\"day\").subtract(this.jDay() , \"day\");\n    }\n    if (nunit === \"jyear\") {\n        this.jMonth(0);\n        nunit = \"jmonth\";\n    }\n    if (nunit === \"jmonth\") {\n        this.jDate(1);\n        nunit = \"day\";\n    }\n    if (nunit === \"day\") {\n        this.hours(0);\n        this.minutes(0);\n        this.seconds(0);\n        this.milliseconds(0);\n        return this;\n    } else {\n        return moment.fn.startOf.call(this, units);\n    }\n};\n\njMoment.fn.endOf = function (units) {\n    units = normalizeUnits(units, this);\n    if (units === undefined || units === \"milisecond\") {\n        return this;\n    }\n    return this.startOf(units).add(1, units).subtract(1, \"ms\");\n};\n\njMoment.fn.isSame = function (other, units) {\n    units = normalizeUnits(units, this);\n    if (units === \"jyear\" || units === \"jmonth\") {\n        return moment.fn.isSame.call(this.clone().startOf(units), other.clone().startOf(units));\n    }\n    return moment.fn.isSame.call(this, other, units);\n};\n\njMoment.fn.isBefore = function (other, units) {\n    units = normalizeUnits(units, this);\n    if (units === \"jyear\" || units === \"jmonth\") {\n        return moment.fn.isBefore.call(this.clone().startOf(units), other.clone().startOf(units));\n    }\n    return moment.fn.isBefore.call(this, other, units);\n};\n\njMoment.fn.isAfter = function (other, units) {\n    units = normalizeUnits(units, this);\n    if (units === \"jyear\" || units === \"jmonth\") {\n        return moment.fn.isAfter.call(this.clone().startOf(units), other.clone().startOf(units));\n    }\n    return moment.fn.isAfter.call(this, other, units);\n};\n\njMoment.fn.clone = function () {\n    return jMoment(this);\n};\n\njMoment.fn.doAsJalali = function () {\n    this.calSystem = CalendarSystems.Jalali;\n    return this;\n};\njMoment.fn.doAsGregorian = function () {\n    this.calSystem = CalendarSystems.Gregorian;\n    return this;\n};\n\njMoment.fn.jYears = jMoment.fn.jYear;\njMoment.fn.jMonths = jMoment.fn.jMonth;\njMoment.fn.jDates = jMoment.fn.jDate;\njMoment.fn.jWeeks = jMoment.fn.jWeek;\n\njMoment.fn.daysInMonth = function() {\n    if (isJalali(this)) {\n        return this.jDaysInMonth();\n    }\n    return moment.fn.daysInMonth.call(this);\n};\njMoment.fn.jDaysInMonth = function () {\n    var month = this.jMonth();\n    var year = this.jYear();\n    if (month < 6) {\n        return 31;\n    } else if (month < 11) {\n        return 30;\n    } else if (jMoment.jIsLeapYear(year)) {\n        return 30;\n    } else {\n        return 29;\n    }\n};\n\njMoment.fn.isLeapYear = function() {\n    if (isJalali(this)) {\n        return this.jIsLeapYear();\n    }\n    return moment.fn.isLeapYear.call(this);\n};\njMoment.fn.jIsLeapYear = function () {\n    var year = this.jYear();\n    return isLeapJalaliYear(year);\n};\njMoment.fn.locale = function(locale) {\n    if (locale && moment.changeCalendarSystemByItsLocale) {\n        if (locale === \"fa\") {\n            this.doAsJalali();\n        } else {\n            this.doAsGregorian();\n        }\n    }\n    return moment.fn.locale.call(this, locale);\n};\n/************************************\n jMoment Statics\n ************************************/\njMoment.locale = function(locale, options) {\n    if (locale && moment.changeCalendarSystemByItsLocale) {\n        if (locale === \"fa\") {\n            this.useJalaliSystemPrimarily(options);\n        } else {\n            this.useJalaliSystemSecondary();\n        }\n    }\n    return moment.locale.call(this, locale);\n};\n\njMoment.from = function(date, locale, format) {\n    var lastLocale = jMoment.locale();\n    jMoment.locale(locale);\n    var m = jMoment(date, format);\n    m.locale(lastLocale);\n    jMoment.locale(lastLocale);\n    return m;\n};\n\njMoment.bindCalendarSystemAndLocale = function () {\n    moment.changeCalendarSystemByItsLocale = true;\n};\njMoment.unBindCalendarSystemAndLocale = function () {\n    moment.changeCalendarSystemByItsLocale = false;\n};\n\njMoment.useJalaliSystemPrimarily = function (options) {\n    moment.justUseJalali = true;\n    var useGregorianParser = false;\n    if (options) {\n        useGregorianParser = options.useGregorianParser;\n    }\n    moment.useGregorianParser = useGregorianParser;\n};\njMoment.useJalaliSystemSecondary = function () {\n    moment.justUseJalali = false;\n};\n\njMoment.jDaysInMonth = function (year, month) {\n    year += div(month, 12);\n    month = mod(month, 12);\n    if (month < 0) {\n        month += 12;\n        year -= 1;\n    }\n    if (month < 6) {\n        return 31;\n    } else if (month < 11) {\n        return 30;\n    } else if (jMoment.jIsLeapYear(year)) {\n        return 30;\n    } else {\n        return 29;\n    }\n};\n\njMoment.jIsLeapYear = isLeapJalaliYear;\n\nmoment.updateLocale(\"fa\", {\n        months: (\"ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر\").split(\"_\")\n        , monthsShort: (\"ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر\").split(\"_\")\n        , weekdays: (\"یک\\u200cشنبه_دوشنبه_سه\\u200cشنبه_چهارشنبه_پنج\\u200cشنبه_جمعه_شنبه\").split(\"_\")\n        , weekdaysShort: (\"یک\\u200cشنبه_دوشنبه_سه\\u200cشنبه_چهارشنبه_پنج\\u200cشنبه_جمعه_شنبه\").split(\"_\")\n        , weekdaysMin: \"ی_د_س_چ_پ_ج_ش\".split(\"_\")\n        , longDateFormat:\n            { LT: \"HH:mm\"\n                , L: \"jYYYY/jMM/jDD\"\n                , LL: \"jD jMMMM jYYYY\"\n                , LLL: \"jD jMMMM jYYYY LT\"\n                , LLLL: \"dddd، jD jMMMM jYYYY LT\"\n            }\n        , calendar:\n            { sameDay: \"[امروز ساعت] LT\"\n                , nextDay: \"[فردا ساعت] LT\"\n                , nextWeek: \"dddd [ساعت] LT\"\n                , lastDay: \"[دیروز ساعت] LT\"\n                , lastWeek: \"dddd [ی پیش ساعت] LT\"\n                , sameElse: \"L\"\n            }\n        , relativeTime:\n            { future: \"در %s\"\n                , past: \"%s پیش\"\n                , s: \"چند ثانیه\"\n                , m: \"1 دقیقه\"\n                , mm: \"%d دقیقه\"\n                , h: \"1 ساعت\"\n                , hh: \"%d ساعت\"\n                , d: \"1 روز\"\n                , dd: \"%d روز\"\n                , M: \"1 ماه\"\n                , MM: \"%d ماه\"\n                , y: \"1 سال\"\n                , yy: \"%d سال\"\n            }\n        , ordinal: \"%dم\",\n        preparse: function (string) {\n            return string;\n        },\n        postformat: function (string) {\n            return string;\n        }\n        , week:\n            { dow: 6 // Saturday is the first day of the week.\n                , doy: 12 // The week that contains Jan 1st is the first week of the year.\n            }\n        , meridiem: function (hour) {\n            return hour < 12 ? \"ق.ظ\" : \"ب.ظ\";\n        }\n        , jMonths: (\"فروردین_اردیبهشت_خرداد_تیر_مرداد_شهریور_مهر_آبان_آذر_دی_بهمن_اسفند\").split(\"_\")\n        , jMonthsShort: \"فروردین_اردیبهشت_خرداد_تیر_مرداد_شهریور_مهر_آبان_آذر_دی_بهمن_اسفند\".split(\"_\")\n    });\njMoment.bindCalendarSystemAndLocale();\nmoment.locale(\"en\");\n\njMoment.jConvert =  { toJalali: toJalali\n    , toGregorian: toGregorian\n};\n\n/************************************\n Jalali Conversion\n ************************************/\n\nfunction toJalali(gy, gm, gd) {\n    var j = convertToJalali(gy, gm + 1, gd);\n    j.jm -= 1;\n    return j;\n}\n\nfunction toGregorian(jy, jm, jd) {\n    var g = convertToGregorian(jy, jm + 1, jd);\n    g.gm -= 1;\n    return g;\n}\n\n/*\n Utility helper functions.\n */\n\nfunction div(a, b) {\n    return ~~(a / b);\n}\n\nfunction mod(a, b) {\n    return a - ~~(a / b) * b;\n}\n\n/*\n Converts a Gregorian date to Jalali.\n */\nfunction convertToJalali(gy, gm, gd) {\n    if (Object.prototype.toString.call(gy) === \"[object Date]\") {\n        gd = gy.getDate();\n        gm = gy.getMonth() + 1;\n        gy = gy.getFullYear();\n    }\n    return d2j(g2d(gy, gm, gd));\n}\n\n/*\n Converts a Jalali date to Gregorian.\n */\nfunction convertToGregorian(jy, jm, jd) {\n    return d2g(j2d(jy, jm, jd));\n}\n\n/*\n Is this a leap year or not?\n */\nfunction isLeapJalaliYear(jy) {\n    return jalCal(jy).leap === 0;\n}\n\n/*\n This function determines if the Jalali (Persian) year is\n leap (366-day long) or is the common year (365 days), and\n finds the day in March (Gregorian calendar) of the first\n day of the Jalali year (jy).\n @param jy Jalali calendar year (-61 to 3177)\n @return\n leap: number of years since the last leap year (0 to 4)\n gy: Gregorian year of the beginning of Jalali year\n march: the March day of Farvardin the 1st (1st day of jy)\n @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm\n @see: http://www.fourmilab.ch/documents/calendar/\n */\nfunction jalCal(jy) {\n    // Jalali years starting the 33-year rule.\n    var breaks =  [ -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210\n        , 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178\n    ]\n        , bl = breaks.length\n        , gy = jy + 621\n        , leapJ = -14\n        , jp = breaks[0]\n        , jm\n        , jump\n        , leap\n        , leapG\n        , march\n        , n\n        , i;\n\n    if (jy < jp || jy >= breaks[bl - 1])\n        throw new Error(\"Invalid Jalali year \" + jy);\n\n    // Find the limiting years for the Jalali year jy.\n    for (i = 1; i < bl; i += 1) {\n        jm = breaks[i];\n        jump = jm - jp;\n        if (jy < jm)\n            break;\n        leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);\n        jp = jm;\n    }\n    n = jy - jp;\n\n    // Find the number of leap years from AD 621 to the beginning\n    // of the current Jalali year in the Persian calendar.\n    leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);\n    if (mod(jump, 33) === 4 && jump - n === 4)\n        leapJ += 1;\n\n    // And the same in the Gregorian calendar (until the year gy).\n    leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;\n\n    // Determine the Gregorian date of Farvardin the 1st.\n    march = 20 + leapJ - leapG;\n\n    // Find how many years have passed since the last leap year.\n    if (jump - n < 6)\n        n = n - jump + div(jump + 4, 33) * 33;\n    leap = mod(mod(n + 1, 33) - 1, 4);\n    if (leap === -1) {\n        leap = 4;\n    }\n\n    return  { leap: leap\n        , gy: gy\n        , march: march\n    };\n}\n\n/*\n Converts a date of the Jalali calendar to the Julian Day number.\n @param jy Jalali year (1 to 3100)\n @param jm Jalali month (1 to 12)\n @param jd Jalali day (1 to 29/31)\n @return Julian Day number\n */\nfunction j2d(jy, jm, jd) {\n    var r = jalCal(jy);\n    return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;\n}\n\n/*\n Converts the Julian Day number to a date in the Jalali calendar.\n @param jdn Julian Day number\n @return\n jy: Jalali year (1 to 3100)\n jm: Jalali month (1 to 12)\n jd: Jalali day (1 to 29/31)\n */\nfunction d2j(jdn) {\n    var gy = d2g(jdn).gy // Calculate Gregorian year (gy).\n        , jy = gy - 621\n        , r = jalCal(jy)\n        , jdn1f = g2d(gy, 3, r.march)\n        , jd\n        , jm\n        , k;\n\n    // Find number of days that passed since 1 Farvardin.\n    k = jdn - jdn1f;\n    if (k >= 0) {\n        if (k <= 185) {\n            // The first 6 months.\n            jm = 1 + div(k, 31);\n            jd = mod(k, 31) + 1;\n            return  { jy: jy\n                , jm: jm\n                , jd: jd\n            };\n        } else {\n            // The remaining months.\n            k -= 186;\n        }\n    } else {\n        // Previous Jalali year.\n        jy -= 1;\n        k += 179;\n        if (r.leap === 1)\n            k += 1;\n    }\n    jm = 7 + div(k, 30);\n    jd = mod(k, 30) + 1;\n    return  { jy: jy\n        , jm: jm\n        , jd: jd\n    };\n}\n\n/*\n Calculates the Julian Day number from Gregorian or Julian\n calendar dates. This integer number corresponds to the noon of\n the date (i.e. 12 hours of Universal Time).\n The procedure was tested to be good since 1 March, -100100 (of both\n calendars) up to a few million years into the future.\n @param gy Calendar year (years BC numbered 0, -1, -2, ...)\n @param gm Calendar month (1 to 12)\n @param gd Calendar day of the month (1 to 28/29/30/31)\n @return Julian Day number\n */\nfunction g2d(gy, gm, gd) {\n    var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4)\n        + div(153 * mod(gm + 9, 12) + 2, 5)\n        + gd - 34840408;\n    d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;\n    return d;\n}\n\n/*\n Calculates Gregorian and Julian calendar dates from the Julian Day number\n (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both\n calendars) to some millions years ahead of the present.\n @param jdn Julian Day number\n @return\n gy: Calendar year (years BC numbered 0, -1, -2, ...)\n gm: Calendar month (1 to 12)\n gd: Calendar day of the month M (1 to 28/29/30/31)\n */\nfunction d2g(jdn) {\n    var j\n        , i\n        , gd\n        , gm\n        , gy;\n    j = 4 * jdn + 139361631;\n    j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;\n    i = div(mod(j, 1461), 4) * 5 + 308;\n    gd = div(mod(i, 153), 5) + 1;\n    gm = mod(div(i, 153), 12) + 1;\n    gy = div(j, 1461) - 100100 + div(8 - gm, 6);\n    return  { gy: gy\n        , gm: gm\n        , gd: gd\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamFsYWxpLW1vbWVudC9qYWxhbGktbW9tZW50LmpzIiwibWFwcGluZ3MiOiI7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsNERBQWU7QUFDcEMsbUJBQU8sQ0FBQyxrRUFBa0I7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRCxJQUFJO0FBQ25FO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0Msa0NBQWtDLEVBQUU7QUFDcEMsaUNBQWlDLElBQUk7QUFDckMsc0NBQXNDLElBQUk7QUFDMUMsbUlBQW1JLElBQUk7QUFDdkk7QUFDQTtBQUNBLCtDQUErQyxJQUFJOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDL0I7QUFDQSxVQUFVLGFBQWEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQ3ZDO0FBQ0EsVUFBVSxhQUFhLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUN2QztBQUNBLFVBQVUsYUFBYSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDdkM7QUFDQSxVQUFVLGFBQWEsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0FBQ3hDO0FBQ0EsVUFBVSxhQUFhLEVBQUUsS0FBSyxFQUFFO0FBQ2hDO0FBQ0EsVUFBVSxhQUFhLEVBQUU7QUFDekI7QUFDQSxVQUFVLGFBQWEsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0FBQ3BDO0FBQ0EsVUFBVSxhQUFhLEVBQUUsSUFBSSxFQUFFO0FBQy9CO0FBQ0EsVUFBVSxhQUFhLEVBQUUsR0FBRyxFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9qYWxhbGktbW9tZW50L2phbGFsaS1tb21lbnQuanM/Yzg0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gak1vbWVudDtcblxudmFyIG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnQvbW9tZW50XCIpO1xucmVxdWlyZShcIm1vbWVudC9sb2NhbGUvZmFcIik7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBDb25zdGFudHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/aihNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3x3W298d10/fFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fCl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U1M/Uz98WHx6ej98Wlo/fC4pL2dcbiAgICAsIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVHxMTD9MP0w/fGx7MSw0fSkvZ1xuICAgICwgcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzID0gL1xcZFxcZD8vXG4gICAgLCBwYXJzZVRva2VuT25lVG9UaHJlZURpZ2l0cyA9IC9cXGR7MSwzfS9cbiAgICAsIHBhcnNlVG9rZW5UaHJlZURpZ2l0cyA9IC9cXGR7M30vXG4gICAgLCBwYXJzZVRva2VuRm91ckRpZ2l0cyA9IC9cXGR7MSw0fS9cbiAgICAsIHBhcnNlVG9rZW5TaXhEaWdpdHMgPSAvWytcXC1dP1xcZHsxLDZ9L1xuICAgICwgcGFyc2VUb2tlbldvcmQgPSAvWzAtOV0qW1wiYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2lcbiAgICAsIHBhcnNlVG9rZW5UaW1lem9uZSA9IC9afFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQvaVxuICAgICwgcGFyc2VUb2tlblQgPSAvVC9pXG4gICAgLCBwYXJzZVRva2VuVGltZXN0YW1wTXMgPSAvW1xcK1xcLV0/XFxkKyhcXC5cXGR7MSwzfSk/L1xuXG4gICAgLCB1bml0QWxpYXNlcyA9IHtcbiAgICAgICAgam06IFwiam1vbnRoXCJcbiAgICAgICAgLCBqbW9udGhzOiBcImptb250aFwiXG4gICAgICAgICwgank6IFwianllYXJcIlxuICAgICAgICAsIGp5ZWFyczogXCJqeWVhclwiXG4gICAgfVxuXG4gICAgLCBmb3JtYXRGdW5jdGlvbnMgPSB7fVxuXG4gICAgLCBvcmRpbmFsaXplVG9rZW5zID0gXCJEREQgdyBNIERcIi5zcGxpdChcIiBcIilcbiAgICAsIHBhZGRlZFRva2VucyA9IFwiTSBEIHdcIi5zcGxpdChcIiBcIik7XG5cbnZhciBDYWxlbmRhclN5c3RlbXMgPSB7XG4gICAgSmFsYWxpOiAxLFxuICAgIEdyZWdvcmlhbjogMixcbn1cbnZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHtcbiAgICBqTTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qTW9udGgoKSArIDE7XG4gICAgfSxcbiAgICBqTU1NOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5qTW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9LFxuICAgIGpNTU1NOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5qTW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSxcbiAgICBqRDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qRGF0ZSgpO1xuICAgIH0sXG4gICAgakRERDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qRGF5T2ZZZWFyKCk7XG4gICAgfSxcbiAgICBqdzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qV2VlaygpO1xuICAgIH0sXG4gICAgallZOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5qWWVhcigpICUgMTAwLCAyKTtcbiAgICB9LFxuICAgIGpZWVlZOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5qWWVhcigpLCA0KTtcbiAgICB9LFxuICAgIGpZWVlZWTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMualllYXIoKSwgNSk7XG4gICAgfSxcbiAgICBqZ2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmpXZWVrWWVhcigpICUgMTAwLCAyKTtcbiAgICB9LFxuICAgIGpnZ2dnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpXZWVrWWVhcigpO1xuICAgIH0sXG4gICAgamdnZ2dnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5qV2Vla1llYXIoKSwgNSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcGFkVG9rZW4oZnVuYywgY291bnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbChmdW5jLmNhbGwodGhpcywgYSksIGNvdW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gb3JkaW5hbGl6ZVRva2VuKGZ1bmMsIHBlcmlvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmNhbGwodGhpcywgYSksIHBlcmlvZCk7XG4gICAgfTtcbn1cblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAob3JkaW5hbGl6ZVRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgaSA9IG9yZGluYWxpemVUb2tlbnMucG9wKCk7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW1wialwiICsgaSArIFwib1wiXSA9IG9yZGluYWxpemVUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9uc1tcImpcIiArIGldLCBpKTtcbiAgICB9XG4gICAgd2hpbGUgKHBhZGRlZFRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgaSA9IHBhZGRlZFRva2Vucy5wb3AoKTtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbXCJqXCIgKyBpICsgaV0gPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9uc1tcImpcIiArIGldLCAyKTtcbiAgICB9XG4gICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMuakREREQgPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9ucy5qRERELCAzKTtcbn0oKSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBIZWxwZXJzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gYilcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiByZXR1cm4gYSBzdHJpbmcgd2hpY2ggbGVuZ3RoIGlzIGFzIG11Y2ggYXMgeW91IG5lZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgaW5wdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRMZW5ndGggZXhwZWN0ZWQgbGVuZ3RoXG4gKiBAZXhhbXBsZSBsZWZ0WmVyb0ZpbGwoNSwyKSA9PiAwNVxuICoqL1xuZnVuY3Rpb24gbGVmdFplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgdmFyIG91dHB1dCA9IG51bWJlciArIFwiXCI7XG4gICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpe1xuICAgICAgICBvdXRwdXQgPSBcIjBcIiArIG91dHB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBkZXRlcm1pbmUgb2JqZWN0IGlzIGFycmF5IG9yIG5vdFxuICogQHBhcmFtIGlucHV0XG4gKiovXG5mdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIGFueSBtb21lbnQgR3JlZ29yaWFuIGZvcm1hdCB0byBKYWxhbGkgc3lzdGVtIGZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdFxuICogQGV4YW1wbGUgdG9KYWxhbGlGb3JtYXQoXCJZWVlZL01NTS9ERFwiKSA9PiBcImpZWVlZL2pNTU0vakREXCJcbiAqKi9cbmZ1bmN0aW9uIHRvSmFsYWxpRm9ybWF0KGZvcm1hdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFpIHx8IChmb3JtYXRbaS0xXSAhPT0gXCJqXCIgJiYgZm9ybWF0W2ktMV0gIT09IGZvcm1hdFtpXSkpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRbaV0gPT09IFwiWVwiIHx8IGZvcm1hdFtpXSA9PT0gXCJNXCIgfHwgZm9ybWF0W2ldID09PSBcIkRcIiB8fCBmb3JtYXRbaV0gPT09IFwiZ1wiKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNsaWNlKDAsIGkpICsgXCJqXCIgKyBmb3JtYXQuc2xpY2UoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIGFueSBtb21lbnQgR3JlZ29yaWFuIHVuaXRzIHRvIEphbGFsaSBzeXN0ZW0gdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0c1xuICogQGV4YW1wbGUgdG9KYWxhbGlVbml0KFwiWVlZWS9NTU0vRERcIikgPT4gXCJqWVlZWS9qTU1NL2pERFwiXG4gKiovXG5mdW5jdGlvbiB0b0phbGFsaVVuaXQodW5pdHMpIHtcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgXCJ3ZWVrXCIgOiByZXR1cm4gXCJqV2Vla1wiO1xuICAgICAgICBjYXNlIFwieWVhclwiIDogcmV0dXJuIFwialllYXJcIjtcbiAgICAgICAgY2FzZSBcIm1vbnRoXCIgOiByZXR1cm4gXCJqTW9udGhcIjtcbiAgICAgICAgY2FzZSBcIm1vbnRoc1wiIDogcmV0dXJuIFwiak1vbnRoc1wiO1xuICAgICAgICBjYXNlIFwibW9udGhOYW1lXCIgOiByZXR1cm4gXCJqTW9udGhzU2hvcnRcIjtcbiAgICAgICAgY2FzZSBcIm1vbnRoc1Nob3J0XCIgOiByZXR1cm4gXCJqTW9udGhzU2hvcnRcIjtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXRzO1xufVxuXG4vKipcbiAqIG5vcm1hbGl6ZSB1bml0cyB0byBiZSBjb21wYXJhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pdHNcbiAqKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzLCBtb21lbnRPYmopIHtcbiAgICBpZiAoaXNKYWxhbGkobW9tZW50T2JqKSkge1xuICAgICAgICB1bml0cyA9IHRvSmFsYWxpVW5pdCh1bml0cyk7XG4gICAgfVxuICAgICBpZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIGxvd2VyZWQgPSB1bml0cy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobG93ZXJlZC5zdGFydHNXaXRoKCdqJykpIHVuaXRzID0gdW5pdEFsaWFzZXNbbG93ZXJlZF0gfHwgbG93ZXJlZDtcbiAgICAgICAgLy8gVE9ETyA6IGFkZCB1bml0IHRlc3RcbiAgICAgICAgaWYgKHVuaXRzID09PSBcImpkYXlcIikgdW5pdHMgPSBcImRheVwiO1xuICAgICAgICBlbHNlIGlmICh1bml0cyA9PT0gXCJqZFwiKSB1bml0cyA9IFwiZFwiO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdHM7XG59XG5cbi8qKlxuICogc2V0IGEgZ3JlZ29yaWFuIGRhdGUgdG8gbW9tZW50IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG1vbWVudEluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30geWVhciBpbiBncmVnb3JpYW4gc3lzdGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9udGggaW4gZ3JlZ29yaWFuIHN5c3RlbVxuICogQHBhcmFtIHtzdHJpbmd9IGRheSBpbiBncmVnb3JpYW4gc3lzdGVtXG4gKiovXG5mdW5jdGlvbiBzZXREYXRlKG1vbWVudEluc3RhbmNlLCB5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgdmFyIGQgPSBtb21lbnRJbnN0YW5jZS5fZDtcbiAgICBpZiAobW9tZW50SW5zdGFuY2UuX2lzVVRDKSB7XG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbmV3LWNhcCovXG4gICAgICAgIG1vbWVudEluc3RhbmNlLl9kID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSxcbiAgICAgICAgICAgIGQuZ2V0VVRDSG91cnMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbGxpc2Vjb25kcygpKSk7XG4gICAgICAgIC8qZXNsaW50LWVuYWJsZSBuZXctY2FwKi9cbiAgICB9IGVsc2Uge1xuICAgICAgICBtb21lbnRJbnN0YW5jZS5fZCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksXG4gICAgICAgICAgICBkLmdldEhvdXJzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaWxsaXNlY29uZHMoKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGUocGFyZW50KSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgRi5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIG5ldyBGKCk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iamVjdCkge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Ype1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwiXCIuX19wcm90b19fKXtcbiAgICAgICAgcmV0dXJuIG9iamVjdC5fX3Byb3RvX187XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIExhbmd1YWdlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4dGVuZChnZXRQcm90b3R5cGVPZihtb21lbnQubG9jYWxlRGF0YSgpKSxcbiAgICB7IF9qTW9udGhzOiBbIFwiRmFydmFyZGluXCJcbiAgICAgICAgLCBcIk9yZGliZWhlc2h0XCJcbiAgICAgICAgLCBcIktob3JkYWFkXCJcbiAgICAgICAgLCBcIlRpclwiXG4gICAgICAgICwgXCJNb3JkYWFkXCJcbiAgICAgICAgLCBcIlNoYWhyaXZhclwiXG4gICAgICAgICwgXCJNZWhyXCJcbiAgICAgICAgLCBcIkFhYmFhblwiXG4gICAgICAgICwgXCJBYXphclwiXG4gICAgICAgICwgXCJEZXlcIlxuICAgICAgICAsIFwiQmFobWFuXCJcbiAgICAgICAgLCBcIkVzZmFuZFwiXG4gICAgXVxuICAgICAgICAsIGpNb250aHM6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9qTW9udGhzW20uak1vbnRoKCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fak1vbnRocztcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICAgICAgLCBfak1vbnRoc1Nob3J0OiAgWyBcIkZhclwiXG4gICAgICAgICwgXCJPcmRcIlxuICAgICAgICAsIFwiS2hvXCJcbiAgICAgICAgLCBcIlRpclwiXG4gICAgICAgICwgXCJBbW9cIlxuICAgICAgICAsIFwiU2hhXCJcbiAgICAgICAgLCBcIk1laFwiXG4gICAgICAgICwgXCJBYWJcIlxuICAgICAgICAsIFwiQWF6XCJcbiAgICAgICAgLCBcIkRleVwiXG4gICAgICAgICwgXCJCYWhcIlxuICAgICAgICAsIFwiRXNmXCJcbiAgICBdXG4gICAgICAgICwgak1vbnRoc1Nob3J0OiBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pNb250aHNTaG9ydFttLmpNb250aCgpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qTW9udGhzU2hvcnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAgICAgLCBqTW9udGhzUGFyc2U6IGZ1bmN0aW9uIChtb250aE5hbWUpIHtcbiAgICAgICAgdmFyIGlcbiAgICAgICAgICAgICwgbW9tXG4gICAgICAgICAgICAsIHJlZ2V4O1xuICAgICAgICBpZiAoIXRoaXMuX2pNb250aHNQYXJzZSl7XG4gICAgICAgICAgICB0aGlzLl9qTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkgKz0gMSkge1xuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uXCJ0IGhhdmUgaXQgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fak1vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gak1vbWVudChbMjAwMCwgKDIgKyBpKSAlIDEyLCAyNV0pO1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gXCJeXCIgKyB0aGlzLmpNb250aHMobW9tLCBcIlwiKSArIFwifF5cIiArIHRoaXMuak1vbnRoc1Nob3J0KG1vbSwgXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fak1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKFwiLlwiLCBcIlwiKSwgXCJpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVzdCB0aGUgcmVnZXguXG4gICAgICAgICAgICBpZiAodGhpcy5fak1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgfVxuKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIEZvcm1hdHRpbmdcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucylcbiAgICAgICAgLCBsZW5ndGggPSBhcnJheS5sZW5ndGhcbiAgICAgICAgLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKXtcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSl7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKXtcbiAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gXCJbXCIgKyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSArIFwiXVwiIDogYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gUGFyc2luZ1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgXCJqRERERFwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSBcImpZWVlZXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbkZvdXJEaWdpdHM7XG4gICAgICAgIGNhc2UgXCJqWVlZWVlcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuU2l4RGlnaXRzO1xuICAgICAgICBjYXNlIFwiakRERFwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVUb1RocmVlRGlnaXRzO1xuICAgICAgICBjYXNlIFwiak1NTVwiOlxuICAgICAgICBjYXNlIFwiak1NTU1cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuV29yZDtcbiAgICAgICAgY2FzZSBcImpNTVwiOlxuICAgICAgICBjYXNlIFwiakREXCI6XG4gICAgICAgIGNhc2UgXCJqWVlcIjpcbiAgICAgICAgY2FzZSBcImpNXCI6XG4gICAgICAgIGNhc2UgXCJqRFwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cztcbiAgICAgICAgY2FzZSBcIkRERERcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGhyZWVEaWdpdHM7XG4gICAgICAgIGNhc2UgXCJZWVlZXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbkZvdXJEaWdpdHM7XG4gICAgICAgIGNhc2UgXCJZWVlZWVwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5TaXhEaWdpdHM7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIGNhc2UgXCJTU1wiOlxuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgIGNhc2UgXCJERERcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lVG9UaHJlZURpZ2l0cztcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICBjYXNlIFwiTU1NTVwiOlxuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgY2FzZSBcImRkZFwiOlxuICAgICAgICBjYXNlIFwiZGRkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5Xb3JkO1xuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5sb2NhbGVEYXRhKGNvbmZpZy5fbCkuX21lcmlkaWVtUGFyc2U7XG4gICAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRpbWVzdGFtcE1zO1xuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGltZXpvbmU7XG4gICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblQ7XG4gICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICBjYXNlIFwiRERcIjpcbiAgICAgICAgY2FzZSBcIllZXCI6XG4gICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICBjYXNlIFwiaGhcIjpcbiAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHRva2VuLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc051bGwodmFyaWFibGUpIHtcbiAgICByZXR1cm4gdmFyaWFibGUgPT09IG51bGwgfHwgdmFyaWFibGUgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgdmFyIGFcbiAgICAgICAgLCBkYXRlUGFydEFycmF5ID0gY29uZmlnLl9hO1xuXG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICBjYXNlIFwiak1cIjpcbiAgICAgICAgY2FzZSBcImpNTVwiOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVsxXSA9IGlzTnVsbChpbnB1dCk/IDAgOiB+fmlucHV0IC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiak1NTVwiOlxuICAgICAgICBjYXNlIFwiak1NTU1cIjpcbiAgICAgICAgICAgIGEgPSBtb21lbnQubG9jYWxlRGF0YShjb25maWcuX2wpLmpNb250aHNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbChhKSl7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVsxXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJqRFwiOlxuICAgICAgICBjYXNlIFwiakREXCI6XG4gICAgICAgIGNhc2UgXCJqREREXCI6XG4gICAgICAgIGNhc2UgXCJqRERERFwiOlxuICAgICAgICAgICAgaWYgKCFpc051bGwoaW5wdXQpKXtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5WzJdID0gfn5pbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiallZXCI6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5WzBdID0gfn5pbnB1dCArICh+fmlucHV0ID4gNDcgPyAxMzAwIDogMTQwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImpZWVlZXCI6XG4gICAgICAgIGNhc2UgXCJqWVlZWVlcIjpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbMF0gPSB+fmlucHV0O1xuICAgIH1cbiAgICBpZiAoaXNOdWxsKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRhdGVGcm9tQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIGdcbiAgICAgICAgLCBqXG4gICAgICAgICwgankgPSBjb25maWcuX2FbMF1cbiAgICAgICAgLCBqbSA9IGNvbmZpZy5fYVsxXVxuICAgICAgICAsIGpkID0gY29uZmlnLl9hWzJdO1xuXG4gICAgaWYgKGlzTnVsbChqeSkgJiYgaXNOdWxsKGptKSAmJiBpc051bGwoamQpKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBqeSA9ICFpc051bGwoankpID8gankgOiAwO1xuICAgIGptID0gIWlzTnVsbChqbSkgPyBqbSA6IDA7XG4gICAgamQgPSAhaXNOdWxsKGpkKSA/IGpkIDogMTtcbiAgICBpZiAoamQgPCAxIHx8IGpkID4gak1vbWVudC5qRGF5c0luTW9udGgoanksIGptKSB8fCBqbSA8IDAgfHwgam0gPiAxMSl7XG4gICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnID0gdG9HcmVnb3JpYW4oanksIGptLCBqZCk7XG4gICAgaiA9IHRvSmFsYWxpKGcuZ3ksIGcuZ20sIGcuZ2QpO1xuICAgIGNvbmZpZy5fakRpZmYgPSAwO1xuICAgIGlmICh+fmouankgIT09IGp5KXtcbiAgICAgICAgY29uZmlnLl9qRGlmZiArPSAxO1xuICAgIH1cbiAgICBpZiAofn5qLmptICE9PSBqbSl7XG4gICAgICAgIGNvbmZpZy5fakRpZmYgKz0gMTtcbiAgICB9XG4gICAgaWYgKH5+ai5qZCAhPT0gamQpe1xuICAgICAgICBjb25maWcuX2pEaWZmICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBbZy5neSwgZy5nbSwgZy5nZF07XG59XG5cbmZ1bmN0aW9uIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICB2YXIgdG9rZW5zID0gY29uZmlnLl9mLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICwgc3RyaW5nID0gY29uZmlnLl9pICsgXCJcIlxuICAgICAgICAsIGxlbiA9IHRva2Vucy5sZW5ndGhcbiAgICAgICAgLCBpXG4gICAgICAgICwgdG9rZW5cbiAgICAgICAgLCBwYXJzZWRJbnB1dDtcblxuICAgIGNvbmZpZy5fYSA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBwYXJzZWRJbnB1dCA9IChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykuZXhlYyhzdHJpbmcpIHx8IFtdKVswXTtcbiAgICAgICAgaWYgKHBhcnNlZElucHV0KXtcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pe1xuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJpbmcpe1xuICAgICAgICBjb25maWcuX2lsID0gc3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUZyb21BcnJheShjb25maWcpO1xufVxuXG5mdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcsIHV0Yykge1xuICAgIHZhciBsZW4gPSBjb25maWcuX2YubGVuZ3RoXG4gICAgICAgICwgaVxuICAgICAgICAsIGZvcm1hdFxuICAgICAgICAsIHRlbXBNb21lbnRcbiAgICAgICAgLCBiZXN0TW9tZW50XG4gICAgICAgICwgY3VycmVudFNjb3JlXG4gICAgICAgICwgc2NvcmVUb0JlYXQ7XG5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBtYWtlTW9tZW50KG5ldyBEYXRlKE5hTikpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBmb3JtYXQgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgIHRlbXBNb21lbnQgPSBtYWtlTW9tZW50KGNvbmZpZy5faSwgZm9ybWF0LCBjb25maWcuX2wsIGNvbmZpZy5fc3RyaWN0LCB1dGMpO1xuXG4gICAgICAgIGlmICghdGVtcE1vbWVudC5pc1ZhbGlkKCkpe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50U2NvcmUgPSBjb21wYXJlQXJyYXlzKHRlbXBNb21lbnQuX2EsIHRlbXBNb21lbnQudG9BcnJheSgpKVxuICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcE1vbWVudC5fakRpZmY7XG4gICAgICAgIGlmICh0ZW1wTW9tZW50Ll9pbCl7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcE1vbWVudC5faWwubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bGwoc2NvcmVUb0JlYXQpIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wTW9tZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RNb21lbnQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVBhcnNlZFRva2Vucyhjb25maWcpIHtcbiAgICB2YXIgc3RyaW5nID0gY29uZmlnLl9pICsgXCJcIlxuICAgICAgICAsIGlucHV0ID0gXCJcIlxuICAgICAgICAsIGZvcm1hdCA9IFwiXCJcbiAgICAgICAgLCBhcnJheSA9IGNvbmZpZy5fZi5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKVxuICAgICAgICAsIGxlbiA9IGFycmF5Lmxlbmd0aFxuICAgICAgICAsIGlcbiAgICAgICAgLCBtYXRjaFxuICAgICAgICAsIHBhcnNlZDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBtYXRjaCA9IGFycmF5W2ldO1xuICAgICAgICBwYXJzZWQgPSAoZ2V0UGFyc2VSZWdleEZvclRva2VuKG1hdGNoLCBjb25maWcpLmV4ZWMoc3RyaW5nKSB8fCBbXSlbMF07XG4gICAgICAgIGlmIChwYXJzZWQpe1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZCkgKyBwYXJzZWQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmb3JtYXRUb2tlbkZ1bmN0aW9uc1ttYXRjaF0gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIGZvcm1hdCArPSBtYXRjaDtcbiAgICAgICAgICAgIGlmIChwYXJzZWQpe1xuICAgICAgICAgICAgICAgIGlucHV0ICs9IHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25maWcuX2kgPSBpbnB1dDtcbiAgICBjb25maWcuX2YgPSBmb3JtYXQ7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBXZWVrIG9mIFllYXJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGpXZWVrT2ZZZWFyKG1vbSwgZmlyc3REYXlPZldlZWssIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyKSB7XG4gICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWtcbiAgICAgICAgLCBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKVxuICAgICAgICAsIGFkanVzdGVkTW9tZW50O1xuXG4gICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICBkYXlzVG9EYXlPZldlZWsgLT0gNztcbiAgICB9XG4gICAgaWYgKGRheXNUb0RheU9mV2VlayA8IGVuZCAtIDcpIHtcbiAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgfVxuICAgIGFkanVzdGVkTW9tZW50ID0gak1vbWVudChtb20pLmFkZChkYXlzVG9EYXlPZldlZWssIFwiZFwiKTtcbiAgICByZXR1cm4gIHsgd2VlazogTWF0aC5jZWlsKGFkanVzdGVkTW9tZW50LmpEYXlPZlllYXIoKSAvIDcpXG4gICAgICAgICwgeWVhcjogYWRqdXN0ZWRNb21lbnQualllYXIoKVxuICAgIH07XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBUb3AgTGV2ZWwgRnVuY3Rpb25zXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZnVuY3Rpb24gaXNKYWxhbGkgKG1vbWVudE9iaikge1xuICAgIHJldHVybiBtb21lbnRPYmogJiZcbiAgICAgICAgKG1vbWVudE9iai5jYWxTeXN0ZW0gPT09IENhbGVuZGFyU3lzdGVtcy5KYWxhbGkpIHx8XG4gICAgICAgIChtb21lbnQuanVzdFVzZUphbGFsaSAmJiBtb21lbnRPYmouY2FsU3lzdGVtICE9PSBDYWxlbmRhclN5c3RlbXMuR3JlZ29yaWFuKTtcbn1cbmZ1bmN0aW9uIGlzSW5wdXRKYWxhbGkoZm9ybWF0LCBtb21lbnRPYmosIGlucHV0KSB7XG4gICAgcmV0dXJuIChtb21lbnQuanVzdFVzZUphbGFsaSB8fCAobW9tZW50T2JqICYmIG1vbWVudE9iai5jYWxTeXN0ZW0gPT09IENhbGVuZGFyU3lzdGVtcy5KYWxhbGkpKVxufVxuZnVuY3Rpb24gbWFrZU1vbWVudChpbnB1dCwgZm9ybWF0LCBsYW5nLCBzdHJpY3QsIHV0Yykge1xuICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdXRjID0gdXRjIHx8IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gbGFuZztcbiAgICAgICAgbGFuZyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG1vbWVudC5JU09fODYwMSA9PT0gZm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTU1onO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dElzSmFsYWxpID0gaXNJbnB1dEphbGFsaShmb3JtYXQsIHRoaXMsIGlucHV0KTtcbiAgICAvLyB2YXIgaXRzSmFsYWxpRGF0ZSA9IChpc0phbGFsaSh0aGlzKSk7XG4gICAgaWYoaW5wdXQgJiYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikgJiYgIWZvcm1hdCAmJiBpbnB1dElzSmFsYWxpICYmICFtb21lbnQudXNlR3JlZ29yaWFuUGFyc2VyKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFwvL2csXCItXCIpO1xuICAgICAgICBpZigvXFxkezR9XFwtXFxkezJ9XFwtXFxkezJ9Ly50ZXN0KGlucHV0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJqWVlZWS1qTU0takREXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVxcLVxcZHsyfVxcLVxcZHsxfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVktak1NLWpEXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVxcLVxcZHsxfVxcLVxcZHsxfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVktak0takRcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFxkezR9XFwtXFxkezF9XFwtXFxkezJ9Ly50ZXN0KGlucHV0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJqWVlZWS1qTS1qRERcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFxkezR9XFwtV1xcZHsyfVxcLVxcZHsyfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVktalctakREXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVxcLVxcZHszfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVktakRERFwiO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXGR7OH0vLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImpZWVlZak1NakREXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcZHs0fVdcXGR7Mn1cXGR7MX0vLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImpZWVlZaldXakRcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFxkezR9V1xcZHsyfS8udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiallZWVlqV1dcIjtcbiAgICAgICAgfSBlbHNlIGlmICgvXFxkezR9XFxkezN9Ly50ZXN0KGlucHV0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJqWVlZWWpERERcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9ybWF0ICYmIGlucHV0SXNKYWxhbGkpe1xuICAgICAgICBmb3JtYXQgPSB0b0phbGFsaUZvcm1hdChmb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ICYmIHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICBmb3JtYXQgPSBmaXhGb3JtYXQoZm9ybWF0LCBtb21lbnQpO1xuICAgIH1cblxuICAgIHZhciBjb25maWcgPVxuICAgICAgICB7IF9pOiBpbnB1dFxuICAgICAgICAgICAgLCBfZjogZm9ybWF0XG4gICAgICAgICAgICAsIF9sOiBsYW5nXG4gICAgICAgICAgICAsIF9zdHJpY3Q6IHN0cmljdFxuICAgICAgICAgICAgLCBfaXNVVEM6IHV0Y1xuICAgICAgICB9XG4gICAgICAgICwgZGF0ZVxuICAgICAgICAsIG1cbiAgICAgICAgLCBqbVxuICAgICAgICAsIG9yaWdJbnB1dCA9IGlucHV0XG4gICAgICAgICwgb3JpZ0Zvcm1hdCA9IGZvcm1hdDtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcsIHV0Yyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgICAgICByZW1vdmVQYXJzZWRUb2tlbnMoY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gXCJZWVlZLU1NLURELVwiICsgY29uZmlnLl9mO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbGVmdFplcm9GaWxsKGRhdGVbMF0sIDQpICsgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgKyBsZWZ0WmVyb0ZpbGwoZGF0ZVsxXSArIDEsIDIpICsgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgKyBsZWZ0WmVyb0ZpbGwoZGF0ZVsyXSwgMikgKyBcIi1cIlxuICAgICAgICAgICAgICAgICAgICArIGNvbmZpZy5faTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXRjKXtcbiAgICAgICAgbSA9IG1vbWVudC51dGMoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0KTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgbSA9IG1vbWVudChpbnB1dCwgZm9ybWF0LCBsYW5nLCBzdHJpY3QpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSB8fCAoaW5wdXQgJiYgaW5wdXQuX2lzQU1vbWVudE9iamVjdCAmJiAhaW5wdXQuX2lzVmFsaWQpKXtcbiAgICAgICAgbS5faXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICBtLl9qRGlmZiA9IGNvbmZpZy5fakRpZmYgfHwgMDtcbiAgICBqbSA9IG9iamVjdENyZWF0ZShqTW9tZW50LmZuKTtcbiAgICBleHRlbmQoam0sIG0pO1xuICAgIGlmIChzdHJpY3QgJiYgam0uaXNWYWxpZCgpKSB7XG4gICAgICAgIGptLl9pc1ZhbGlkID0gam0uZm9ybWF0KG9yaWdGb3JtYXQpID09PSBvcmlnSW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dCAmJiBpbnB1dC5jYWxTeXN0ZW0pIHtcbiAgICAgICAgam0uY2FsU3lzdGVtID0gaW5wdXQuY2FsU3lzdGVtO1xuICAgIH1cbiAgICByZXR1cm4gam07XG59XG5cbmZ1bmN0aW9uIGpNb21lbnQoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0KSB7XG4gICAgcmV0dXJuIG1ha2VNb21lbnQoaW5wdXQsIGZvcm1hdCwgbGFuZywgc3RyaWN0LCBmYWxzZSk7XG59XG5cbmV4dGVuZChqTW9tZW50LCBtb21lbnQpO1xuak1vbWVudC5mbiA9IG9iamVjdENyZWF0ZShtb21lbnQuZm4pO1xuXG5qTW9tZW50LnV0YyA9IGZ1bmN0aW9uIChpbnB1dCwgZm9ybWF0LCBsYW5nLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gbWFrZU1vbWVudChpbnB1dCwgZm9ybWF0LCBsYW5nLCBzdHJpY3QsIHRydWUpO1xufTtcblxuak1vbWVudC51bml4ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIG1ha2VNb21lbnQoaW5wdXQgKiAxMDAwKTtcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBqTW9tZW50IFByb3RvdHlwZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gZml4Rm9ybWF0KGZvcm1hdCwgX21vbWVudCkge1xuICAgIHZhciBpID0gNTtcbiAgICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gX21vbWVudC5sb2NhbGVEYXRhKCkubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgIH07XG4gICAgd2hpbGUgKGkgPiAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgaSAtPSAxO1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0O1xufVxuXG5qTW9tZW50LmZuLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0Zm9ybWF0ID0gZm9ybWF0IHx8IGpNb21lbnQuZGVmYXVsdEZvcm1hdDtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChpc0phbGFsaSh0aGlzKSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gdG9KYWxhbGlGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXQgPSBmaXhGb3JtYXQoZm9ybWF0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIWZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVkID0gbW9tZW50LmZuLmZvcm1hdC5jYWxsKHRoaXMsIGZvcm1hdCk7XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbn07XG5cbmpNb21lbnQuZm4ueWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpc0phbGFsaSh0aGlzKSkgcmV0dXJuIGpNb21lbnQuZm4ualllYXIuY2FsbCh0aGlzLGlucHV0KTtcbiAgICBlbHNlIHJldHVybiBtb21lbnQuZm4ueWVhci5jYWxsKHRoaXMsIGlucHV0KTtcbn07XG5qTW9tZW50LmZuLmpZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIGxhc3REYXlcbiAgICAgICAgLCBqXG4gICAgICAgICwgZztcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGogPSBnZXRKYWxhbGlPZih0aGlzKTtcbiAgICAgICAgbGFzdERheSA9IE1hdGgubWluKGouamQsIGpNb21lbnQuakRheXNJbk1vbnRoKGlucHV0LCBqLmptKSk7XG4gICAgICAgIGcgPSB0b0dyZWdvcmlhbihpbnB1dCwgai5qbSwgbGFzdERheSk7XG4gICAgICAgIHNldERhdGUodGhpcywgZy5neSwgZy5nbSwgZy5nZCk7XG4gICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRKYWxhbGlPZih0aGlzKS5qeTtcbiAgICB9XG59O1xuXG5qTW9tZW50LmZuLm1vbnRoID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlzSmFsYWxpKHRoaXMpKSByZXR1cm4gak1vbWVudC5mbi5qTW9udGguY2FsbCh0aGlzLGlucHV0KTtcbiAgICBlbHNlIHJldHVybiBtb21lbnQuZm4ubW9udGguY2FsbCh0aGlzLCBpbnB1dCk7XG59O1xuak1vbWVudC5mbi5qTW9udGggPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgbGFzdERheVxuICAgICAgICAsIGpcbiAgICAgICAgLCBnO1xuICAgIGlmICghaXNOdWxsKGlucHV0KSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHRoaXMubG9jYWxlRGF0YSgpLmpNb250aHNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBqID0gZ2V0SmFsYWxpT2YodGhpcyk7XG4gICAgICAgIGxhc3REYXkgPSBNYXRoLm1pbihqLmpkLCBqTW9tZW50LmpEYXlzSW5Nb250aChqLmp5LCBpbnB1dCkpO1xuICAgICAgICB0aGlzLmpZZWFyKGouankgKyBkaXYoaW5wdXQsIDEyKSk7XG4gICAgICAgIGlucHV0ID0gbW9kKGlucHV0LCAxMik7XG4gICAgICAgIGlmIChpbnB1dCA8IDApIHtcbiAgICAgICAgICAgIGlucHV0ICs9IDEyO1xuICAgICAgICAgICAgdGhpcy5qWWVhcih0aGlzLmpZZWFyKCkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBnID0gdG9HcmVnb3JpYW4odGhpcy5qWWVhcigpLCBpbnB1dCwgbGFzdERheSk7XG4gICAgICAgIHNldERhdGUodGhpcywgZy5neSwgZy5nbSwgZy5nZCk7XG4gICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRKYWxhbGlPZih0aGlzKS5qbTtcbiAgICB9XG59O1xuXG5qTW9tZW50LmZuLmRhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaXNKYWxhbGkodGhpcykpIHJldHVybiBqTW9tZW50LmZuLmpEYXRlLmNhbGwodGhpcyxpbnB1dCk7XG4gICAgZWxzZSByZXR1cm4gbW9tZW50LmZuLmRhdGUuY2FsbCh0aGlzLCBpbnB1dCk7XG59O1xuZnVuY3Rpb24gZ2V0SmFsYWxpT2YgKG1vbWVudE9iaikge1xuICAgIHZhciBkID0gbW9tZW50T2JqLl9kO1xuICAgIGlmIChtb21lbnRPYmouX2lzVVRDKSB7XG4gICAgICAgIHJldHVybiB0b0phbGFsaShkLmdldFVUQ0Z1bGxZZWFyKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENEYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b0phbGFsaShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICAgIH1cbn1cbmpNb21lbnQuZm4uakRhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgalxuICAgICAgICAsIGc7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBqID0gZ2V0SmFsYWxpT2YodGhpcyk7XG4gICAgICAgIGcgPSB0b0dyZWdvcmlhbihqLmp5LCBqLmptLCBpbnB1dCk7XG4gICAgICAgIHNldERhdGUodGhpcywgZy5neSwgZy5nbSwgZy5nZCk7XG4gICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRKYWxhbGlPZih0aGlzKS5qZDtcbiAgICB9XG59O1xuXG5qTW9tZW50LmZuLmpEYXkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQuZm4uZGF5LmNhbGwodGhpcywgaW5wdXQgLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKG1vbWVudC5mbi5kYXkuY2FsbCh0aGlzKSArIDEpICUgNztcbiAgICB9XG59O1xuak1vbWVudC5mbi5kaWZmID0gZnVuY3Rpb24gKGlucHV0LCB1bml0T2ZUaW1lLCBhc0Zsb2F0KSB7XG4gICAgLy9jb2RlIHRha2VuIGFuZCBhZGp1c3RlZCBmb3IgamFsYWxpIGNhbGVuZGFyIGZyb20gb3JpZ2luYWwgbW9tZW50IGRpZmYgbW9kdWxlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvZGV2ZWxvcC9zcmMvbGliL21vbWVudC9kaWZmLmpzXG4gICAgaWYgKCFpc0phbGFsaSh0aGlzKSlcbiAgICAgICAgcmV0dXJuIG1vbWVudC5mbi5kaWZmLmNhbGwodGhpcywgaW5wdXQsIHVuaXRPZlRpbWUsIGFzRmxvYXQpO1xuXG4gICAgdmFyIG91dHB1dDtcbiAgICBzd2l0Y2ggKHVuaXRPZlRpbWUpIHtcbiAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCBpbnB1dCkgLyAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCBpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInF1YXJ0ZXJcIjpcbiAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCBpbnB1dCkgLyAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvdXRwdXQgPSBtb21lbnQuZm4uZGlmZi5jYWxsKHRoaXMsIGlucHV0LCB1bml0T2ZUaW1lLCBhc0Zsb2F0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IChvdXRwdXQgPCAwID8gTWF0aC5jZWlsKG91dHB1dCkgfHwgMCA6IE1hdGguZmxvb3Iob3V0cHV0KSk7XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYoYSwgYikge1xuICAgICAgICBpZiAoYS5kYXRlKCkgPCBiLmRhdGUoKSkge1xuICAgICAgICAgICAgLy8gZW5kLW9mLW1vbnRoIGNhbGN1bGF0aW9ucyB3b3JrIGNvcnJlY3Qgd2hlbiB0aGUgc3RhcnQgbW9udGggaGFzIG1vcmVcbiAgICAgICAgICAgIC8vIGRheXMgdGhhbiB0aGUgZW5kIG1vbnRoLlxuICAgICAgICAgICAgcmV0dXJuIC1tb250aERpZmYoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKGIualllYXIoKSAtIGEualllYXIoKSkgKiAxMiArIChiLmpNb250aCgpIC0gYS5qTW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgXCJtb250aHNcIiksXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgYWRqdXN0XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsIFwibW9udGhzXCIpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgXCJtb250aHNcIik7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG59XG5cbmpNb21lbnQuZm4uZGF5T2ZZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlzSmFsYWxpKHRoaXMpKSByZXR1cm4gak1vbWVudC5mbi5qRGF5T2ZZZWFyLmNhbGwodGhpcyxpbnB1dCk7XG4gICAgZWxzZSByZXR1cm4gbW9tZW50LmZuLmRheU9mWWVhci5jYWxsKHRoaXMsIGlucHV0KTtcbn07XG5qTW9tZW50LmZuLmpEYXlPZlllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgoak1vbWVudCh0aGlzKS5zdGFydE9mKFwiZGF5XCIpIC0gak1vbWVudCh0aGlzKS5zdGFydE9mKFwialllYXJcIikpIC8gODY0ZTUpICsgMTtcbiAgICByZXR1cm4gaXNOdWxsKGlucHV0KSA/IGRheU9mWWVhciA6IHRoaXMuYWRkKGlucHV0IC0gZGF5T2ZZZWFyLCBcImRcIik7XG59O1xuXG5qTW9tZW50LmZuLndlZWsgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaXNKYWxhbGkodGhpcykpIHJldHVybiBqTW9tZW50LmZuLmpXZWVrLmNhbGwodGhpcyxpbnB1dCk7XG4gICAgZWxzZSByZXR1cm4gbW9tZW50LmZuLndlZWsuY2FsbCh0aGlzLCBpbnB1dCk7XG59O1xuak1vbWVudC5mbi5qV2VlayA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0galdlZWtPZlllYXIodGhpcywgNiwgMTIpLndlZWs7XG4gICAgcmV0dXJuIGlzTnVsbChpbnB1dCkgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCBcImRcIik7XG59O1xuXG5qTW9tZW50LmZuLndlZWtZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlzSmFsYWxpKHRoaXMpKSByZXR1cm4gak1vbWVudC5mbi5qV2Vla1llYXIuY2FsbCh0aGlzLGlucHV0KTtcbiAgICBlbHNlIHJldHVybiBtb21lbnQuZm4ud2Vla1llYXIuY2FsbCh0aGlzLCBpbnB1dCk7XG59O1xuak1vbWVudC5mbi5qV2Vla1llYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgeWVhciA9IGpXZWVrT2ZZZWFyKHRoaXMsIDYsIDEyKS55ZWFyO1xuICAgIHJldHVybiBpc051bGwoaW5wdXQpID8geWVhciA6IHRoaXMuYWRkKGlucHV0IC0geWVhciwgXCJqeWVhclwiKTtcbn07XG5cbmpNb21lbnQuZm4uYWRkID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcbiAgICB2YXIgdGVtcDtcbiAgICBpZiAoIWlzTnVsbCh1bml0cykgJiYgIWlzTmFOKCt1bml0cykpIHtcbiAgICAgICAgdGVtcCA9IHZhbDtcbiAgICAgICAgdmFsID0gdW5pdHM7XG4gICAgICAgIHVuaXRzID0gdGVtcDtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cywgdGhpcyk7XG4gICAgaWYgKHVuaXRzID09PSAnandlZWsnIHx8IHVuaXRzPT09J2lzb3dlZWsnKSB7IHVuaXRzID0gJ3dlZWsnIH1cbiAgICBpZiAodW5pdHMgPT09IFwianllYXJcIikge1xuICAgICAgICB0aGlzLmpZZWFyKHRoaXMualllYXIoKSArIHZhbCk7XG4gICAgfSBlbHNlIGlmICh1bml0cyA9PT0gXCJqbW9udGhcIikge1xuICAgICAgICB0aGlzLmpNb250aCh0aGlzLmpNb250aCgpICsgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtb21lbnQuZm4uYWRkLmNhbGwodGhpcywgdmFsLCB1bml0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuak1vbWVudC5mbi5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG4gICAgdmFyIHRlbXA7XG4gICAgaWYgKCFpc051bGwodW5pdHMpICYmICFpc05hTigrdW5pdHMpKSB7XG4gICAgICAgIHRlbXAgPSB2YWw7XG4gICAgICAgIHZhbCA9IHVuaXRzO1xuICAgICAgICB1bml0cyA9IHRlbXA7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMsIHRoaXMpO1xuICAgIGlmICh1bml0cyA9PT0gXCJqeWVhclwiKSB7XG4gICAgICAgIHRoaXMualllYXIodGhpcy5qWWVhcigpIC0gdmFsKTtcbiAgICB9IGVsc2UgaWYgKHVuaXRzID09PSBcImptb250aFwiKSB7XG4gICAgICAgIHRoaXMuak1vbnRoKHRoaXMuak1vbnRoKCkgLSB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vbWVudC5mbi5zdWJ0cmFjdC5jYWxsKHRoaXMsIHZhbCwgdW5pdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmpNb21lbnQuZm4uc3RhcnRPZiA9IGZ1bmN0aW9uICh1bml0cykge1xuICAgIHZhciBudW5pdCA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzLCB0aGlzKTtcbiAgICBpZiggbnVuaXQgPT09IFwiandlZWtcIil7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YoXCJkYXlcIikuc3VidHJhY3QodGhpcy5qRGF5KCkgLCBcImRheVwiKTtcbiAgICB9XG4gICAgaWYgKG51bml0ID09PSBcImp5ZWFyXCIpIHtcbiAgICAgICAgdGhpcy5qTW9udGgoMCk7XG4gICAgICAgIG51bml0ID0gXCJqbW9udGhcIjtcbiAgICB9XG4gICAgaWYgKG51bml0ID09PSBcImptb250aFwiKSB7XG4gICAgICAgIHRoaXMuakRhdGUoMSk7XG4gICAgICAgIG51bml0ID0gXCJkYXlcIjtcbiAgICB9XG4gICAgaWYgKG51bml0ID09PSBcImRheVwiKSB7XG4gICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC5mbi5zdGFydE9mLmNhbGwodGhpcywgdW5pdHMpO1xuICAgIH1cbn07XG5cbmpNb21lbnQuZm4uZW5kT2YgPSBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzLCB0aGlzKTtcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gXCJtaWxpc2Vjb25kXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCB1bml0cykuc3VidHJhY3QoMSwgXCJtc1wiKTtcbn07XG5cbmpNb21lbnQuZm4uaXNTYW1lID0gZnVuY3Rpb24gKG90aGVyLCB1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMsIHRoaXMpO1xuICAgIGlmICh1bml0cyA9PT0gXCJqeWVhclwiIHx8IHVuaXRzID09PSBcImptb250aFwiKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQuZm4uaXNTYW1lLmNhbGwodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLCBvdGhlci5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbWVudC5mbi5pc1NhbWUuY2FsbCh0aGlzLCBvdGhlciwgdW5pdHMpO1xufTtcblxuak1vbWVudC5mbi5pc0JlZm9yZSA9IGZ1bmN0aW9uIChvdGhlciwgdW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzLCB0aGlzKTtcbiAgICBpZiAodW5pdHMgPT09IFwianllYXJcIiB8fCB1bml0cyA9PT0gXCJqbW9udGhcIikge1xuICAgICAgICByZXR1cm4gbW9tZW50LmZuLmlzQmVmb3JlLmNhbGwodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLCBvdGhlci5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbWVudC5mbi5pc0JlZm9yZS5jYWxsKHRoaXMsIG90aGVyLCB1bml0cyk7XG59O1xuXG5qTW9tZW50LmZuLmlzQWZ0ZXIgPSBmdW5jdGlvbiAob3RoZXIsIHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cywgdGhpcyk7XG4gICAgaWYgKHVuaXRzID09PSBcImp5ZWFyXCIgfHwgdW5pdHMgPT09IFwiam1vbnRoXCIpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudC5mbi5pc0FmdGVyLmNhbGwodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLCBvdGhlci5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbWVudC5mbi5pc0FmdGVyLmNhbGwodGhpcywgb3RoZXIsIHVuaXRzKTtcbn07XG5cbmpNb21lbnQuZm4uY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGpNb21lbnQodGhpcyk7XG59O1xuXG5qTW9tZW50LmZuLmRvQXNKYWxhbGkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxTeXN0ZW0gPSBDYWxlbmRhclN5c3RlbXMuSmFsYWxpO1xuICAgIHJldHVybiB0aGlzO1xufTtcbmpNb21lbnQuZm4uZG9Bc0dyZWdvcmlhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbFN5c3RlbSA9IENhbGVuZGFyU3lzdGVtcy5HcmVnb3JpYW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5qTW9tZW50LmZuLmpZZWFycyA9IGpNb21lbnQuZm4ualllYXI7XG5qTW9tZW50LmZuLmpNb250aHMgPSBqTW9tZW50LmZuLmpNb250aDtcbmpNb21lbnQuZm4uakRhdGVzID0gak1vbWVudC5mbi5qRGF0ZTtcbmpNb21lbnQuZm4ualdlZWtzID0gak1vbWVudC5mbi5qV2Vlaztcblxuak1vbWVudC5mbi5kYXlzSW5Nb250aCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChpc0phbGFsaSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qRGF5c0luTW9udGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbWVudC5mbi5kYXlzSW5Nb250aC5jYWxsKHRoaXMpO1xufTtcbmpNb21lbnQuZm4uakRheXNJbk1vbnRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb250aCA9IHRoaXMuak1vbnRoKCk7XG4gICAgdmFyIHllYXIgPSB0aGlzLmpZZWFyKCk7XG4gICAgaWYgKG1vbnRoIDwgNikge1xuICAgICAgICByZXR1cm4gMzE7XG4gICAgfSBlbHNlIGlmIChtb250aCA8IDExKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9IGVsc2UgaWYgKGpNb21lbnQuaklzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAyOTtcbiAgICB9XG59O1xuXG5qTW9tZW50LmZuLmlzTGVhcFllYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoaXNKYWxhbGkodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaklzTGVhcFllYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbWVudC5mbi5pc0xlYXBZZWFyLmNhbGwodGhpcyk7XG59O1xuak1vbWVudC5mbi5qSXNMZWFwWWVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeWVhciA9IHRoaXMualllYXIoKTtcbiAgICByZXR1cm4gaXNMZWFwSmFsYWxpWWVhcih5ZWFyKTtcbn07XG5qTW9tZW50LmZuLmxvY2FsZSA9IGZ1bmN0aW9uKGxvY2FsZSkge1xuICAgIGlmIChsb2NhbGUgJiYgbW9tZW50LmNoYW5nZUNhbGVuZGFyU3lzdGVtQnlJdHNMb2NhbGUpIHtcbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gXCJmYVwiKSB7XG4gICAgICAgICAgICB0aGlzLmRvQXNKYWxhbGkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9Bc0dyZWdvcmlhbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQuZm4ubG9jYWxlLmNhbGwodGhpcywgbG9jYWxlKTtcbn07XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gak1vbWVudCBTdGF0aWNzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuak1vbWVudC5sb2NhbGUgPSBmdW5jdGlvbihsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICBpZiAobG9jYWxlICYmIG1vbWVudC5jaGFuZ2VDYWxlbmRhclN5c3RlbUJ5SXRzTG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUgPT09IFwiZmFcIikge1xuICAgICAgICAgICAgdGhpcy51c2VKYWxhbGlTeXN0ZW1QcmltYXJpbHkob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVzZUphbGFsaVN5c3RlbVNlY29uZGFyeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb21lbnQubG9jYWxlLmNhbGwodGhpcywgbG9jYWxlKTtcbn07XG5cbmpNb21lbnQuZnJvbSA9IGZ1bmN0aW9uKGRhdGUsIGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgdmFyIGxhc3RMb2NhbGUgPSBqTW9tZW50LmxvY2FsZSgpO1xuICAgIGpNb21lbnQubG9jYWxlKGxvY2FsZSk7XG4gICAgdmFyIG0gPSBqTW9tZW50KGRhdGUsIGZvcm1hdCk7XG4gICAgbS5sb2NhbGUobGFzdExvY2FsZSk7XG4gICAgak1vbWVudC5sb2NhbGUobGFzdExvY2FsZSk7XG4gICAgcmV0dXJuIG07XG59O1xuXG5qTW9tZW50LmJpbmRDYWxlbmRhclN5c3RlbUFuZExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBtb21lbnQuY2hhbmdlQ2FsZW5kYXJTeXN0ZW1CeUl0c0xvY2FsZSA9IHRydWU7XG59O1xuak1vbWVudC51bkJpbmRDYWxlbmRhclN5c3RlbUFuZExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBtb21lbnQuY2hhbmdlQ2FsZW5kYXJTeXN0ZW1CeUl0c0xvY2FsZSA9IGZhbHNlO1xufTtcblxuak1vbWVudC51c2VKYWxhbGlTeXN0ZW1QcmltYXJpbHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG1vbWVudC5qdXN0VXNlSmFsYWxpID0gdHJ1ZTtcbiAgICB2YXIgdXNlR3JlZ29yaWFuUGFyc2VyID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdXNlR3JlZ29yaWFuUGFyc2VyID0gb3B0aW9ucy51c2VHcmVnb3JpYW5QYXJzZXI7XG4gICAgfVxuICAgIG1vbWVudC51c2VHcmVnb3JpYW5QYXJzZXIgPSB1c2VHcmVnb3JpYW5QYXJzZXI7XG59O1xuak1vbWVudC51c2VKYWxhbGlTeXN0ZW1TZWNvbmRhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgbW9tZW50Lmp1c3RVc2VKYWxhbGkgPSBmYWxzZTtcbn07XG5cbmpNb21lbnQuakRheXNJbk1vbnRoID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgeWVhciArPSBkaXYobW9udGgsIDEyKTtcbiAgICBtb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgIGlmIChtb250aCA8IDApIHtcbiAgICAgICAgbW9udGggKz0gMTI7XG4gICAgICAgIHllYXIgLT0gMTtcbiAgICB9XG4gICAgaWYgKG1vbnRoIDwgNikge1xuICAgICAgICByZXR1cm4gMzE7XG4gICAgfSBlbHNlIGlmIChtb250aCA8IDExKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICB9IGVsc2UgaWYgKGpNb21lbnQuaklzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAyOTtcbiAgICB9XG59O1xuXG5qTW9tZW50LmpJc0xlYXBZZWFyID0gaXNMZWFwSmFsYWxpWWVhcjtcblxubW9tZW50LnVwZGF0ZUxvY2FsZShcImZhXCIsIHtcbiAgICAgICAgbW9udGhzOiAoXCLamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixXCIpLnNwbGl0KFwiX1wiKVxuICAgICAgICAsIG1vbnRoc1Nob3J0OiAoXCLamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixXCIpLnNwbGl0KFwiX1wiKVxuICAgICAgICAsIHdlZWtkYXlzOiAoXCLbjNqpXFx1MjAwY9i02YbYqNmHX9iv2YjYtNmG2KjZh1/Ys9mHXFx1MjAwY9i02YbYqNmHX9qG2YfYp9ix2LTZhtio2Ydf2b7ZhtisXFx1MjAwY9i02YbYqNmHX9is2YXYudmHX9i02YbYqNmHXCIpLnNwbGl0KFwiX1wiKVxuICAgICAgICAsIHdlZWtkYXlzU2hvcnQ6IChcItuM2qlcXHUyMDBj2LTZhtio2Ydf2K/ZiNi02YbYqNmHX9iz2YdcXHUyMDBj2LTZhtio2Ydf2obZh9in2LHYtNmG2KjZh1/ZvtmG2KxcXHUyMDBj2LTZhtio2Ydf2KzZhdi52Ydf2LTZhtio2YdcIikuc3BsaXQoXCJfXCIpXG4gICAgICAgICwgd2Vla2RheXNNaW46IFwi24xf2K9f2LNf2oZf2b5f2Kxf2LRcIi5zcGxpdChcIl9cIilcbiAgICAgICAgLCBsb25nRGF0ZUZvcm1hdDpcbiAgICAgICAgICAgIHsgTFQ6IFwiSEg6bW1cIlxuICAgICAgICAgICAgICAgICwgTDogXCJqWVlZWS9qTU0vakREXCJcbiAgICAgICAgICAgICAgICAsIExMOiBcImpEIGpNTU1NIGpZWVlZXCJcbiAgICAgICAgICAgICAgICAsIExMTDogXCJqRCBqTU1NTSBqWVlZWSBMVFwiXG4gICAgICAgICAgICAgICAgLCBMTExMOiBcImRkZGTYjCBqRCBqTU1NTSBqWVlZWSBMVFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICwgY2FsZW5kYXI6XG4gICAgICAgICAgICB7IHNhbWVEYXk6IFwiW9in2YXYsdmI2LIg2LPYp9i52KpdIExUXCJcbiAgICAgICAgICAgICAgICAsIG5leHREYXk6IFwiW9mB2LHYr9inINiz2KfYudiqXSBMVFwiXG4gICAgICAgICAgICAgICAgLCBuZXh0V2VlazogXCJkZGRkIFvYs9in2LnYql0gTFRcIlxuICAgICAgICAgICAgICAgICwgbGFzdERheTogXCJb2K/bjNix2YjYsiDYs9in2LnYql0gTFRcIlxuICAgICAgICAgICAgICAgICwgbGFzdFdlZWs6IFwiZGRkZCBb24wg2b7bjNi0INiz2KfYudiqXSBMVFwiXG4gICAgICAgICAgICAgICAgLCBzYW1lRWxzZTogXCJMXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgLCByZWxhdGl2ZVRpbWU6XG4gICAgICAgICAgICB7IGZ1dHVyZTogXCLYr9ixICVzXCJcbiAgICAgICAgICAgICAgICAsIHBhc3Q6IFwiJXMg2b7bjNi0XCJcbiAgICAgICAgICAgICAgICAsIHM6IFwi2obZhtivINir2KfZhtuM2YdcIlxuICAgICAgICAgICAgICAgICwgbTogXCIxINiv2YLbjNmC2YdcIlxuICAgICAgICAgICAgICAgICwgbW06IFwiJWQg2K/ZgtuM2YLZh1wiXG4gICAgICAgICAgICAgICAgLCBoOiBcIjEg2LPYp9i52KpcIlxuICAgICAgICAgICAgICAgICwgaGg6IFwiJWQg2LPYp9i52KpcIlxuICAgICAgICAgICAgICAgICwgZDogXCIxINix2YjYslwiXG4gICAgICAgICAgICAgICAgLCBkZDogXCIlZCDYsdmI2LJcIlxuICAgICAgICAgICAgICAgICwgTTogXCIxINmF2KfZh1wiXG4gICAgICAgICAgICAgICAgLCBNTTogXCIlZCDZhdin2YdcIlxuICAgICAgICAgICAgICAgICwgeTogXCIxINiz2KfZhFwiXG4gICAgICAgICAgICAgICAgLCB5eTogXCIlZCDYs9in2YRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAsIG9yZGluYWw6IFwiJWTZhVwiLFxuICAgICAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICAsIHdlZWs6XG4gICAgICAgICAgICB7IGRvdzogNiAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgICAgICwgZG95OiAxMiAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgICAgICAgICB9XG4gICAgICAgICwgbWVyaWRpZW06IGZ1bmN0aW9uIChob3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gaG91ciA8IDEyID8gXCLZgi7YuFwiIDogXCLYqC7YuFwiO1xuICAgICAgICB9XG4gICAgICAgICwgak1vbnRoczogKFwi2YHYsdmI2LHYr9uM2YZf2KfYsdiv24zYqNmH2LTYql/Yrtix2K/Yp9ivX9iq24zYsV/Zhdix2K/Yp9ivX9i02YfYsduM2YjYsV/ZhdmH2LFf2KLYqNin2YZf2KLYsNixX9iv24xf2KjZh9mF2YZf2KfYs9mB2YbYr1wiKS5zcGxpdChcIl9cIilcbiAgICAgICAgLCBqTW9udGhzU2hvcnQ6IFwi2YHYsdmI2LHYr9uM2YZf2KfYsdiv24zYqNmH2LTYql/Yrtix2K/Yp9ivX9iq24zYsV/Zhdix2K/Yp9ivX9i02YfYsduM2YjYsV/ZhdmH2LFf2KLYqNin2YZf2KLYsNixX9iv24xf2KjZh9mF2YZf2KfYs9mB2YbYr1wiLnNwbGl0KFwiX1wiKVxuICAgIH0pO1xuak1vbWVudC5iaW5kQ2FsZW5kYXJTeXN0ZW1BbmRMb2NhbGUoKTtcbm1vbWVudC5sb2NhbGUoXCJlblwiKTtcblxuak1vbWVudC5qQ29udmVydCA9ICB7IHRvSmFsYWxpOiB0b0phbGFsaVxuICAgICwgdG9HcmVnb3JpYW46IHRvR3JlZ29yaWFuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gSmFsYWxpIENvbnZlcnNpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIHRvSmFsYWxpKGd5LCBnbSwgZ2QpIHtcbiAgICB2YXIgaiA9IGNvbnZlcnRUb0phbGFsaShneSwgZ20gKyAxLCBnZCk7XG4gICAgai5qbSAtPSAxO1xuICAgIHJldHVybiBqO1xufVxuXG5mdW5jdGlvbiB0b0dyZWdvcmlhbihqeSwgam0sIGpkKSB7XG4gICAgdmFyIGcgPSBjb252ZXJ0VG9HcmVnb3JpYW4oanksIGptICsgMSwgamQpO1xuICAgIGcuZ20gLT0gMTtcbiAgICByZXR1cm4gZztcbn1cblxuLypcbiBVdGlsaXR5IGhlbHBlciBmdW5jdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gZGl2KGEsIGIpIHtcbiAgICByZXR1cm4gfn4oYSAvIGIpO1xufVxuXG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIHJldHVybiBhIC0gfn4oYSAvIGIpICogYjtcbn1cblxuLypcbiBDb252ZXJ0cyBhIEdyZWdvcmlhbiBkYXRlIHRvIEphbGFsaS5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvSmFsYWxpKGd5LCBnbSwgZ2QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGd5KSA9PT0gXCJbb2JqZWN0IERhdGVdXCIpIHtcbiAgICAgICAgZ2QgPSBneS5nZXREYXRlKCk7XG4gICAgICAgIGdtID0gZ3kuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgIGd5ID0gZ3kuZ2V0RnVsbFllYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGQyaihnMmQoZ3ksIGdtLCBnZCkpO1xufVxuXG4vKlxuIENvbnZlcnRzIGEgSmFsYWxpIGRhdGUgdG8gR3JlZ29yaWFuLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9HcmVnb3JpYW4oanksIGptLCBqZCkge1xuICAgIHJldHVybiBkMmcoajJkKGp5LCBqbSwgamQpKTtcbn1cblxuLypcbiBJcyB0aGlzIGEgbGVhcCB5ZWFyIG9yIG5vdD9cbiAqL1xuZnVuY3Rpb24gaXNMZWFwSmFsYWxpWWVhcihqeSkge1xuICAgIHJldHVybiBqYWxDYWwoankpLmxlYXAgPT09IDA7XG59XG5cbi8qXG4gVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIHRoZSBKYWxhbGkgKFBlcnNpYW4pIHllYXIgaXNcbiBsZWFwICgzNjYtZGF5IGxvbmcpIG9yIGlzIHRoZSBjb21tb24geWVhciAoMzY1IGRheXMpLCBhbmRcbiBmaW5kcyB0aGUgZGF5IGluIE1hcmNoIChHcmVnb3JpYW4gY2FsZW5kYXIpIG9mIHRoZSBmaXJzdFxuIGRheSBvZiB0aGUgSmFsYWxpIHllYXIgKGp5KS5cbiBAcGFyYW0gankgSmFsYWxpIGNhbGVuZGFyIHllYXIgKC02MSB0byAzMTc3KVxuIEByZXR1cm5cbiBsZWFwOiBudW1iZXIgb2YgeWVhcnMgc2luY2UgdGhlIGxhc3QgbGVhcCB5ZWFyICgwIHRvIDQpXG4gZ3k6IEdyZWdvcmlhbiB5ZWFyIG9mIHRoZSBiZWdpbm5pbmcgb2YgSmFsYWxpIHllYXJcbiBtYXJjaDogdGhlIE1hcmNoIGRheSBvZiBGYXJ2YXJkaW4gdGhlIDFzdCAoMXN0IGRheSBvZiBqeSlcbiBAc2VlOiBodHRwOi8vd3d3LmFzdHJvLnVuaS50b3J1bi5wbC9+a2IvUGFwZXJzL0VNUC9QZXJzaWFuQy1FTVAuaHRtXG4gQHNlZTogaHR0cDovL3d3dy5mb3VybWlsYWIuY2gvZG9jdW1lbnRzL2NhbGVuZGFyL1xuICovXG5mdW5jdGlvbiBqYWxDYWwoankpIHtcbiAgICAvLyBKYWxhbGkgeWVhcnMgc3RhcnRpbmcgdGhlIDMzLXllYXIgcnVsZS5cbiAgICB2YXIgYnJlYWtzID0gIFsgLTYxLCA5LCAzOCwgMTk5LCA0MjYsIDY4NiwgNzU2LCA4MTgsIDExMTEsIDExODEsIDEyMTBcbiAgICAgICAgLCAxNjM1LCAyMDYwLCAyMDk3LCAyMTkyLCAyMjYyLCAyMzI0LCAyMzk0LCAyNDU2LCAzMTc4XG4gICAgXVxuICAgICAgICAsIGJsID0gYnJlYWtzLmxlbmd0aFxuICAgICAgICAsIGd5ID0gankgKyA2MjFcbiAgICAgICAgLCBsZWFwSiA9IC0xNFxuICAgICAgICAsIGpwID0gYnJlYWtzWzBdXG4gICAgICAgICwgam1cbiAgICAgICAgLCBqdW1wXG4gICAgICAgICwgbGVhcFxuICAgICAgICAsIGxlYXBHXG4gICAgICAgICwgbWFyY2hcbiAgICAgICAgLCBuXG4gICAgICAgICwgaTtcblxuICAgIGlmIChqeSA8IGpwIHx8IGp5ID49IGJyZWFrc1tibCAtIDFdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEphbGFsaSB5ZWFyIFwiICsgankpO1xuXG4gICAgLy8gRmluZCB0aGUgbGltaXRpbmcgeWVhcnMgZm9yIHRoZSBKYWxhbGkgeWVhciBqeS5cbiAgICBmb3IgKGkgPSAxOyBpIDwgYmw7IGkgKz0gMSkge1xuICAgICAgICBqbSA9IGJyZWFrc1tpXTtcbiAgICAgICAganVtcCA9IGptIC0ganA7XG4gICAgICAgIGlmIChqeSA8IGptKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxlYXBKID0gbGVhcEogKyBkaXYoanVtcCwgMzMpICogOCArIGRpdihtb2QoanVtcCwgMzMpLCA0KTtcbiAgICAgICAganAgPSBqbTtcbiAgICB9XG4gICAgbiA9IGp5IC0ganA7XG5cbiAgICAvLyBGaW5kIHRoZSBudW1iZXIgb2YgbGVhcCB5ZWFycyBmcm9tIEFEIDYyMSB0byB0aGUgYmVnaW5uaW5nXG4gICAgLy8gb2YgdGhlIGN1cnJlbnQgSmFsYWxpIHllYXIgaW4gdGhlIFBlcnNpYW4gY2FsZW5kYXIuXG4gICAgbGVhcEogPSBsZWFwSiArIGRpdihuLCAzMykgKiA4ICsgZGl2KG1vZChuLCAzMykgKyAzLCA0KTtcbiAgICBpZiAobW9kKGp1bXAsIDMzKSA9PT0gNCAmJiBqdW1wIC0gbiA9PT0gNClcbiAgICAgICAgbGVhcEogKz0gMTtcblxuICAgIC8vIEFuZCB0aGUgc2FtZSBpbiB0aGUgR3JlZ29yaWFuIGNhbGVuZGFyICh1bnRpbCB0aGUgeWVhciBneSkuXG4gICAgbGVhcEcgPSBkaXYoZ3ksIDQpIC0gZGl2KChkaXYoZ3ksIDEwMCkgKyAxKSAqIDMsIDQpIC0gMTUwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBHcmVnb3JpYW4gZGF0ZSBvZiBGYXJ2YXJkaW4gdGhlIDFzdC5cbiAgICBtYXJjaCA9IDIwICsgbGVhcEogLSBsZWFwRztcblxuICAgIC8vIEZpbmQgaG93IG1hbnkgeWVhcnMgaGF2ZSBwYXNzZWQgc2luY2UgdGhlIGxhc3QgbGVhcCB5ZWFyLlxuICAgIGlmIChqdW1wIC0gbiA8IDYpXG4gICAgICAgIG4gPSBuIC0ganVtcCArIGRpdihqdW1wICsgNCwgMzMpICogMzM7XG4gICAgbGVhcCA9IG1vZChtb2QobiArIDEsIDMzKSAtIDEsIDQpO1xuICAgIGlmIChsZWFwID09PSAtMSkge1xuICAgICAgICBsZWFwID0gNDtcbiAgICB9XG5cbiAgICByZXR1cm4gIHsgbGVhcDogbGVhcFxuICAgICAgICAsIGd5OiBneVxuICAgICAgICAsIG1hcmNoOiBtYXJjaFxuICAgIH07XG59XG5cbi8qXG4gQ29udmVydHMgYSBkYXRlIG9mIHRoZSBKYWxhbGkgY2FsZW5kYXIgdG8gdGhlIEp1bGlhbiBEYXkgbnVtYmVyLlxuIEBwYXJhbSBqeSBKYWxhbGkgeWVhciAoMSB0byAzMTAwKVxuIEBwYXJhbSBqbSBKYWxhbGkgbW9udGggKDEgdG8gMTIpXG4gQHBhcmFtIGpkIEphbGFsaSBkYXkgKDEgdG8gMjkvMzEpXG4gQHJldHVybiBKdWxpYW4gRGF5IG51bWJlclxuICovXG5mdW5jdGlvbiBqMmQoanksIGptLCBqZCkge1xuICAgIHZhciByID0gamFsQ2FsKGp5KTtcbiAgICByZXR1cm4gZzJkKHIuZ3ksIDMsIHIubWFyY2gpICsgKGptIC0gMSkgKiAzMSAtIGRpdihqbSwgNykgKiAoam0gLSA3KSArIGpkIC0gMTtcbn1cblxuLypcbiBDb252ZXJ0cyB0aGUgSnVsaWFuIERheSBudW1iZXIgdG8gYSBkYXRlIGluIHRoZSBKYWxhbGkgY2FsZW5kYXIuXG4gQHBhcmFtIGpkbiBKdWxpYW4gRGF5IG51bWJlclxuIEByZXR1cm5cbiBqeTogSmFsYWxpIHllYXIgKDEgdG8gMzEwMClcbiBqbTogSmFsYWxpIG1vbnRoICgxIHRvIDEyKVxuIGpkOiBKYWxhbGkgZGF5ICgxIHRvIDI5LzMxKVxuICovXG5mdW5jdGlvbiBkMmooamRuKSB7XG4gICAgdmFyIGd5ID0gZDJnKGpkbikuZ3kgLy8gQ2FsY3VsYXRlIEdyZWdvcmlhbiB5ZWFyIChneSkuXG4gICAgICAgICwgankgPSBneSAtIDYyMVxuICAgICAgICAsIHIgPSBqYWxDYWwoankpXG4gICAgICAgICwgamRuMWYgPSBnMmQoZ3ksIDMsIHIubWFyY2gpXG4gICAgICAgICwgamRcbiAgICAgICAgLCBqbVxuICAgICAgICAsIGs7XG5cbiAgICAvLyBGaW5kIG51bWJlciBvZiBkYXlzIHRoYXQgcGFzc2VkIHNpbmNlIDEgRmFydmFyZGluLlxuICAgIGsgPSBqZG4gLSBqZG4xZjtcbiAgICBpZiAoayA+PSAwKSB7XG4gICAgICAgIGlmIChrIDw9IDE4NSkge1xuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IDYgbW9udGhzLlxuICAgICAgICAgICAgam0gPSAxICsgZGl2KGssIDMxKTtcbiAgICAgICAgICAgIGpkID0gbW9kKGssIDMxKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gIHsgank6IGp5XG4gICAgICAgICAgICAgICAgLCBqbTogam1cbiAgICAgICAgICAgICAgICAsIGpkOiBqZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgbW9udGhzLlxuICAgICAgICAgICAgayAtPSAxODY7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQcmV2aW91cyBKYWxhbGkgeWVhci5cbiAgICAgICAgankgLT0gMTtcbiAgICAgICAgayArPSAxNzk7XG4gICAgICAgIGlmIChyLmxlYXAgPT09IDEpXG4gICAgICAgICAgICBrICs9IDE7XG4gICAgfVxuICAgIGptID0gNyArIGRpdihrLCAzMCk7XG4gICAgamQgPSBtb2QoaywgMzApICsgMTtcbiAgICByZXR1cm4gIHsgank6IGp5XG4gICAgICAgICwgam06IGptXG4gICAgICAgICwgamQ6IGpkXG4gICAgfTtcbn1cblxuLypcbiBDYWxjdWxhdGVzIHRoZSBKdWxpYW4gRGF5IG51bWJlciBmcm9tIEdyZWdvcmlhbiBvciBKdWxpYW5cbiBjYWxlbmRhciBkYXRlcy4gVGhpcyBpbnRlZ2VyIG51bWJlciBjb3JyZXNwb25kcyB0byB0aGUgbm9vbiBvZlxuIHRoZSBkYXRlIChpLmUuIDEyIGhvdXJzIG9mIFVuaXZlcnNhbCBUaW1lKS5cbiBUaGUgcHJvY2VkdXJlIHdhcyB0ZXN0ZWQgdG8gYmUgZ29vZCBzaW5jZSAxIE1hcmNoLCAtMTAwMTAwIChvZiBib3RoXG4gY2FsZW5kYXJzKSB1cCB0byBhIGZldyBtaWxsaW9uIHllYXJzIGludG8gdGhlIGZ1dHVyZS5cbiBAcGFyYW0gZ3kgQ2FsZW5kYXIgeWVhciAoeWVhcnMgQkMgbnVtYmVyZWQgMCwgLTEsIC0yLCAuLi4pXG4gQHBhcmFtIGdtIENhbGVuZGFyIG1vbnRoICgxIHRvIDEyKVxuIEBwYXJhbSBnZCBDYWxlbmRhciBkYXkgb2YgdGhlIG1vbnRoICgxIHRvIDI4LzI5LzMwLzMxKVxuIEByZXR1cm4gSnVsaWFuIERheSBudW1iZXJcbiAqL1xuZnVuY3Rpb24gZzJkKGd5LCBnbSwgZ2QpIHtcbiAgICB2YXIgZCA9IGRpdigoZ3kgKyBkaXYoZ20gLSA4LCA2KSArIDEwMDEwMCkgKiAxNDYxLCA0KVxuICAgICAgICArIGRpdigxNTMgKiBtb2QoZ20gKyA5LCAxMikgKyAyLCA1KVxuICAgICAgICArIGdkIC0gMzQ4NDA0MDg7XG4gICAgZCA9IGQgLSBkaXYoZGl2KGd5ICsgMTAwMTAwICsgZGl2KGdtIC0gOCwgNiksIDEwMCkgKiAzLCA0KSArIDc1MjtcbiAgICByZXR1cm4gZDtcbn1cblxuLypcbiBDYWxjdWxhdGVzIEdyZWdvcmlhbiBhbmQgSnVsaWFuIGNhbGVuZGFyIGRhdGVzIGZyb20gdGhlIEp1bGlhbiBEYXkgbnVtYmVyXG4gKGpkbikgZm9yIHRoZSBwZXJpb2Qgc2luY2UgamRuPS0zNDgzOTY1NSAoaS5lLiB0aGUgeWVhciAtMTAwMTAwIG9mIGJvdGhcbiBjYWxlbmRhcnMpIHRvIHNvbWUgbWlsbGlvbnMgeWVhcnMgYWhlYWQgb2YgdGhlIHByZXNlbnQuXG4gQHBhcmFtIGpkbiBKdWxpYW4gRGF5IG51bWJlclxuIEByZXR1cm5cbiBneTogQ2FsZW5kYXIgeWVhciAoeWVhcnMgQkMgbnVtYmVyZWQgMCwgLTEsIC0yLCAuLi4pXG4gZ206IENhbGVuZGFyIG1vbnRoICgxIHRvIDEyKVxuIGdkOiBDYWxlbmRhciBkYXkgb2YgdGhlIG1vbnRoIE0gKDEgdG8gMjgvMjkvMzAvMzEpXG4gKi9cbmZ1bmN0aW9uIGQyZyhqZG4pIHtcbiAgICB2YXIgalxuICAgICAgICAsIGlcbiAgICAgICAgLCBnZFxuICAgICAgICAsIGdtXG4gICAgICAgICwgZ3k7XG4gICAgaiA9IDQgKiBqZG4gKyAxMzkzNjE2MzE7XG4gICAgaiA9IGogKyBkaXYoZGl2KDQgKiBqZG4gKyAxODMxODc3MjAsIDE0NjA5NykgKiAzLCA0KSAqIDQgLSAzOTA4O1xuICAgIGkgPSBkaXYobW9kKGosIDE0NjEpLCA0KSAqIDUgKyAzMDg7XG4gICAgZ2QgPSBkaXYobW9kKGksIDE1MyksIDUpICsgMTtcbiAgICBnbSA9IG1vZChkaXYoaSwgMTUzKSwgMTIpICsgMTtcbiAgICBneSA9IGRpdihqLCAxNDYxKSAtIDEwMDEwMCArIGRpdig4IC0gZ20sIDYpO1xuICAgIHJldHVybiAgeyBneTogZ3lcbiAgICAgICAgLCBnbTogZ21cbiAgICAgICAgLCBnZDogZ2RcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jalali-moment/jalali-moment.js\n");

/***/ })

};
;